<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ë™≠Êõ∏ track</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23ffffff'/%3E%3Cpath d='M25 20 L25 80 L50 75 L75 80 L75 20 L50 25 Z' fill='%23000000'/%3E%3Cline x1='50' y1='25' x2='50' y2='75' stroke='%23ffffff' stroke-width='2'/%3E%3Cline x1='32' y1='35' x2='45' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='43' x2='45' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='51' x2='45' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='59' x2='45' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='35' x2='68' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='43' x2='68' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='51' x2='68' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='59' x2='68' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="far4mB8aQQrQ4OshhK5PYwtcgJ1XDn02389aFZjIAjk" />
  <link href="https://fonts.googleapis.com/css2?family=Klee+One:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://accounts.google.com/gsi/client" async defer></script> 
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border-color: #30363d;
      --text-primary: #c9d1d9;
      --text-secondary: #8b949e;
      --accent-color: #238636;
      --accent-hover: #2ea043;
      --danger-color: #da3633;
      --danger-hover: #f85149;
      --level-0: #161b22;
      --level-1: #0e4429;
      --level-2: #006d32;
      --level-3: #26a641;
      --level-4: #39d353;
    }
    
    body.theme-nord {
  --bg-primary: #2e3440;
  --bg-secondary: #3b4252;
  --bg-tertiary: #434c5e;
  --border-color: #4c566a;
  --text-primary: #eceff4;
  --text-secondary: #d8dee9;
  --accent-color: #88c0d0;
  --accent-hover: #8fbcbb;
  --danger-color: #bf616a;
  --danger-hover: #d08770;
  --level-0: #3b4252;
  --level-1: #4d6780;
  --level-2: #5e81ac;
  --level-3: #7a99c4;
  --level-4: #96b1dc;
}

body.theme-tokyo {
  --bg-primary: #1a1b26;
  --bg-secondary: #16161e;
  --bg-tertiary: #24283b;
  --border-color: #414868;
  --text-primary: #a9b1d6;
  --text-secondary: #565f89;
  --accent-color: #7aa2f7;
  --accent-hover: #7dcfff;
  --danger-color: #f7768e;
  --danger-hover: #ff9e64;
  --level-0: #24283b;
  --level-1: #3d5a8f;
  --level-2: #5678c4;
  --level-3: #7aa2f7;
  --level-4: #a4c0ff;
}

body.theme-dracula {
  --bg-primary: #282a36;
  --bg-secondary: #21222c;
  --bg-tertiary: #343746;
  --border-color: #44475a;
  --text-primary: #f8f8f2;
  --text-secondary: #6272a4;
  --accent-color: #ff5555;
  --accent-hover: #ff6e6e;
  --danger-color: #ff5555;
  --danger-hover: #ff6e6e;
  --level-0: #44475a;
  --level-1: #6e3a3a;
  --level-2: #8b4545;
  --level-3: #ff5555;
  --level-4: #ff7979;
}

body.theme-dracula .month-label,
body.theme-dracula .day-label {
  color: #ff5555;
}

body.theme-everforest {
  --bg-primary: #fdf6e3;
  --bg-secondary: #f4f0d9;
  --bg-tertiary: #efebd4;
  --border-color: #e0dcc7;
  --text-primary: #5c6a72;
  --text-secondary: #939f91;
  --accent-color: #8da101;
  --accent-hover: #a7b901;
  --danger-color: #f85552;
  --danger-hover: #e66868;
  --level-0: #f4f0d9;
  --level-1: #b9ca4a;
  --level-2: #a7c080;
  --level-3: #8da101;
  --level-4: #6f8800;
}

body.theme-onedark {
  --bg-primary: #282c34;
  --bg-secondary: #21252b;
  --bg-tertiary: #2c313c;
  --border-color: #3e4451;
  --text-primary: #abb2bf;
  --text-secondary: #5c6370;
  --accent-color: #98c379;
  --accent-hover: #b5cea8;
  --danger-color: #e06c75;
  --danger-hover: #be5046;
  --level-0: #21252b;
  --level-1: #5a8a5e;
  --level-2: #74a774;
  --level-3: #98c379;
  --level-4: #b5d8a0;
}

body.theme-nord-light {
  --bg-primary: #eceff4;
  --bg-secondary: #e5e9f0;
  --bg-tertiary: #d8dee9;
  --border-color: #c2c9d6;
  --text-primary: #2e3440;
  --text-secondary: #4c566a;
  --accent-color: #5e81ac;
  --accent-hover: #81a1c1;
  --danger-color: #bf616a;
  --danger-hover: #d08770;
  --level-0: #e5e9f0;
  --level-1: #a8c5db;
  --level-2: #81a1c1;
  --level-3: #5e81ac;
  --level-4: #4c6a95;
}

body.theme-phoenix {
  --bg-primary: #170f1e;
  --bg-secondary: #1c1521;
  --bg-tertiary: #2b2032;
  --border-color: #3d2f47;
  --text-primary: #f5c2e7;
  --text-secondary: #988ba2;
  --accent-color: #cba6f7;
  --accent-hover: #d4b4f8;
  --danger-color: #f38ba8;
  --danger-hover: #f5a7bc;
  --level-0: #1c1521;
  --level-1: #8b6ba8;
  --level-2: #a888c7;
  --level-3: #cba6f7;
  --level-4: #e0c8ff;
}
body.theme-phoenix {
  --bg-primary: #170f1e;
  --bg-secondary: #1c1521;
  --bg-tertiary: #2b2032;
  --border-color: #3d2f47;
  --text-primary: #f5c2e7;
  --text-secondary: #988ba2;
  --accent-color: #cba6f7;
  --accent-hover: #d4b4f8;
  --danger-color: #f38ba8;
  --danger-hover: #f5a7bc;
  --level-0: #1c1521;
  --level-1: #8b6ba8;
  --level-2: #a888c7;
  --level-3: #cba6f7;
  --level-4: #e0c8ff;
}

body.theme-ereader {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e8e8e8;
  --border-color: #d0d0d0;
  --text-primary: #000000;
  --text-secondary: #666666;
  --accent-color: #333333;
  --accent-hover: #000000;
  --danger-color: #555555;
  --danger-hover: #333333;
  --level-0: #ffffff;
  --level-1: #d0d0d0;
  --level-2: #a0a0a0;
  --level-3: #666666;
  --level-4: #333333;
}

/* Stats modal polish */
#statsModal .modal-content {
  /* Ensure consistent width across themes and avoid cramped layout */
  width: 520px;
  max-width: 95vw;
}

#statsModal label input[type="checkbox"] {
  /* Match other inputs and avoid oversized checkbox hitbox */
  width: 16px;
  height: 16px;
  cursor: pointer;
}

@media (max-width: 600px) {
  #statsModal .modal-content {
    width: 96vw;
  }
}

/* Emphasize Disable Sync as a destructive action */
#ttsuSyncModal .btn[onclick="disableTtsuSync()"] {
  border: 1px solid var(--danger-color);
}
#ttsuSyncModal .btn[onclick="disableTtsuSync()"]:hover {
  border-color: var(--danger-hover);
}

#ttsuSyncModal #ttsuSyncStatus.success {
  background: rgba(35, 134, 54, 0.15);
  border-color: var(--accent-color);
}


/* E-reader specific optimizations */
body.theme-ereader {
  font-size: 16px;
  line-height: 1.6;
}

body.theme-ereader .container {
  max-width: 100%;
  padding: 20px 15px;
}

body.theme-ereader h1 {
  font-size: 22px;
  color: #000000;
}

body.theme-ereader .day {
  width: 16px;
  height: 16px;
  border: 1px solid #d0d0d0;
}

body.theme-ereader .btn,
body.theme-ereader .log-btn,
body.theme-ereader select,
body.theme-ereader input {
  border: 2px solid #333333;
  box-shadow: none;
}

body.theme-ereader .heatmap-panel,
body.theme-ereader .leaderboard-panel,
body.theme-ereader .goals-section {
  box-shadow: none;
  border: 2px solid #d0d0d0;
}

body.theme-ereader .icon-btn:hover,
body.theme-ereader .btn:hover {
  background: #e8e8e8;
  box-shadow: none;
}

body.theme-ereader .log-btn {
  background: #333333;
  color: #ffffff;
  box-shadow: none;
}

body.theme-ereader .log-btn:hover {
  background: #000000;
  box-shadow: none;
  transform: none;
}

body.theme-ereader .day:hover {
  outline: 2px solid #000000;
  box-shadow: none;
  transform: scale(1.1);
}

body.theme-ereader .modal-content {
  box-shadow: none;
  border: 3px solid #333333;
}

body.theme-ereader .entry-item,
body.theme-ereader .leaderboard-entry {
  box-shadow: none;
  border: 1px solid #d0d0d0;
}

/* Optimize for 7-inch screen (typical resolution: 1264x1680 or 1072x1448) */
@media screen and (max-width: 1280px) and (max-height: 1700px) {
  body.theme-ereader {
    font-size: 15px;
  }
  
  body.theme-ereader .container {
    max-width: 100%;
    padding: 15px 10px;
  }
  
  body.theme-ereader h1 {
    font-size: 20px;
  }
  
  body.theme-ereader .controls {
    flex-wrap: wrap;
    gap: 8px;
  }
  
  body.theme-ereader .day {
    width: 14px;
    height: 14px;
  }
  
  body.theme-ereader .btn,
  body.theme-ereader .log-btn {
    padding: 8px 12px;
    font-size: 14px;
  }
  
  body.theme-ereader .metric-option {
    padding: 6px 10px;
    font-size: 13px;
  }
}
    
    body {
      font-family: "Klee One", cursive;
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 40px 20px;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    html {
      overflow-x: hidden;
      background: var(--bg-primary);
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }

    h1 {
      font-size: 24px;
      font-weight: 700;
      color: #ffffff;
    }
    body.theme-everforest h1,
    body.theme-nord-light h1,
    body.theme-ereader h1 {
      color: var(--text-primary);
}

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .icon-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      padding: 8px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-size: 18px;
    }

    .icon-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    
    .user-profile {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--bg-tertiary);
      padding: 6px 12px;
      border-radius: 20px;
      cursor: pointer;
    }
    
    .user-profile:hover {
      background: var(--border-color);
    }
    
    .user-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
    }
    
    .user-name {
      font-size: 14px;
      color: var(--text-primary);
    }

    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      align-items: center;
    }

    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .btn:hover {
      background: var(--border-color);
      border-color: var(--text-secondary);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    /* Reduce shadows on light themes */
body.theme-everforest .heatmap-panel,
body.theme-everforest .leaderboard-panel,
body.theme-everforest .modal-content,
body.theme-nord-light .heatmap-panel,
body.theme-nord-light .leaderboard-panel,
body.theme-nord-light .modal-content,
body.theme-ereader .heatmap-panel,
body.theme-ereader .leaderboard-panel,
body.theme-ereader .modal-content {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

body.theme-everforest .btn,
body.theme-everforest .day,
body.theme-nord-light .btn,
body.theme-nord-light .day,
body.theme-ereader .btn,
body.theme-ereader .day {
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

body.theme-everforest .btn:hover,
body.theme-nord-light .btn:hover,
body.theme-ereader .btn:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

body.theme-everforest .log-btn,
body.theme-nord-light .log-btn,
body.theme-ereader .log-btn {
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

body.theme-everforest .log-btn:hover,
body.theme-nord-light .log-btn:hover,
body.theme-ereader .log-btn:hover {
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
}

    select, input[type="number"] {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .heatmap-panel {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .day-labels {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 12px;
      color: var(--text-secondary);
      margin-right: 8px;
      padding-top: 24px;
    }

    .day-label {
      height: 14px;
      line-height: 14px;
      display: flex;
      align-items: center;
    }
    
    .day-label:nth-child(2),
    .day-label:nth-child(4),
    .day-label:nth-child(6),
    .day-label:nth-child(7) {
      visibility: hidden;
    }

    .calendar-wrapper {
      display: flex;
      overflow-x: auto;
      padding-bottom: 4px;
      scrollbar-width: none;
    }

    .calendar-wrapper::-webkit-scrollbar {
      display: none;
    }

    .calendar {
      display: flex;
      gap: 5px;
    }

    .month {
      display: flex;
      flex-direction: column;
    }

    .month-label {
      font-size: 11px;
      font-weight: 400;
      color: var(--text-secondary);
      margin-bottom: 4px;
      height: 16px;
      padding-left: 8px;
    }

    .weeks {
      display: flex;
      gap: 5px;
    }

    .week {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .week.partial-start {
      padding-top: calc(var(--offset, 0) * (14px + 6px));
    }

    .day {
      width: 14px;
      height: 14px;
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.15s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }

    .day.empty {
      background: var(--level-0);
      border: 1px solid var(--border-color);
    }

    .day.level-1 { background: var(--level-1); }
    .day.level-2 { background: var(--level-2); }
    .day.level-3 { background: var(--level-3); }
    .day.level-4 { background: var(--level-4); }

    .day:hover {
      outline: 1.5px solid rgba(255, 255, 255, 0.7);
      outline-offset: 1px;
      transform: scale(1.2);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .day.today {
      outline: 2px solid var(--accent-color);
      outline-offset: 1px;
    }

    .stats-section {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
    }

    .stats {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .stat-line {
      display: flex;
      gap: 4px;
    }

    .stat-value {
      color: var(--text-primary);
      font-weight: 600;
    }

    .log-btn {
  background: var(--accent-color);
  border: none;
  color: #ffffff;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
  filter: drop-shadow(0 4px 12px var(--accent-color));
}

.log-btn:hover {
  background: var(--accent-hover);
  filter: drop-shadow(0 6px 16px var(--accent-color));
  transform: translateY(-2px);
}

    .tooltip {
      position: fixed;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      display: none;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      max-width: 250px;
    }

    .tooltip.show {
      display: block;
    }

    .tooltip-date {
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text-primary);
    }

    .tooltip-value {
      color: var(--text-secondary);
      font-size: 11px;
    }

    .tooltip-titles {
      color: var(--text-secondary);
      font-size: 11px;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid var(--border-color);
    }

    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 24px;
      width: 460px;
      max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
    }

    .modal h2 {
      margin-bottom: 16px;
      font-size: 18px;
      color: var(--text-primary);
    }

    .form-group {
      margin-bottom: 14px;
    }

    .form-label {
      display: block;
      color: var(--text-primary);
      font-size: 13px;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .form-input {
      width: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 12px rgba(88, 166, 255, 0.15);
    }

    textarea.form-input {
      min-height: 80px;
      resize: vertical;
      font-family: inherit;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 12px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .legend-item {
      width: 14px;
      height: 14px;
      border-radius: 2px;
    }

    @media (max-width: 768px) {
      .stats-section {
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
      }
    }

    .entry-list {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
      max-height: 300px;
      overflow-y: auto;
    }

    .entry-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--text-primary);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .entry-item:hover {
      background: var(--bg-tertiary);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
    }

    .entry-info {
      flex: 1;
    }

    .entry-detail {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .delete-btn {
      background: var(--danger-color);
      border: none;
      color: #ffffff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 8px;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(218, 54, 51, 0.3);
    }

    .delete-btn:hover {
      background: var(--danger-hover);
      box-shadow: 0 4px 12px rgba(248, 81, 73, 0.4);
      transform: translateY(-1px);
    }

    .metric-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 2px 4px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .metric-toggle:hover {
      background: rgba(0, 0, 0, 0.4);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .metric-option {
      padding: 6px 14px;
      border-radius: 16px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s ease;
      color: #a0a0a0;
      background: transparent;
      border: none;
      cursor: pointer;
    }

    .metric-option.active {
      background: rgba(255, 255, 255, 0.1);
      color: #fcfcfc;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transform: scale(1.05);
    }
    
    .goals-section {
      margin-top: 20px;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 6px;
      border: 1px solid var(--border-color);
    }
    
    .goal-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border-color);
    }
    
    .goal-item:last-child {
      border-bottom: none;
    }
    
    .goal-progress {
      width: 100%;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
    }
    
    .goal-progress-bar {
      height: 100%;
      background: var(--accent-color);
      transition: width 0.3s;
    }
    
    .leaderboard-panel {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 24px;
      margin-top: 32px;
      margin-bottom: 20px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: 4px;
      margin-bottom: 8px;
      transition: all 0.2s;
    }
    
    .leaderboard-entry:hover {
      background: var(--bg-tertiary);
      transform: translateX(4px);
    }
    
    .leaderboard-rank {
      font-size: 20px;
      font-weight: 700;
      min-width: 40px;
      color: var(--text-secondary);
    }
    
    .leaderboard-user {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .leaderboard-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent-color);
    }
    
    .quick-log-books {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    
    .quick-book-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 6px 12px;
      border-radius: 16px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .quick-book-btn:hover {
      background: var(--border-color);
      transform: translateY(-1px);
    }
    
    .quick-book-btn.active {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
    }
    
    .toggle-section-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      margin-right: 8px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    
    .toggle-section-btn:hover {
      background: var(--border-color);
      transform: translateY(-1px);
    }
    
    .toggle-section-btn.active {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
    }
    
    .toggle-buttons {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      margin-bottom: 8px;
    }
    
    .theme-selector {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-top: 12px;
  row-gap: 20px;
}

@media (max-width: 600px) {
  .theme-selector {
    grid-template-columns: repeat(2, 1fr);
  }
}
    
    .theme-preview {
  padding: 24px 16px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s;
  text-align: center;
  font-size: 13px;
  min-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}
    
    .theme-preview:hover {
      transform: scale(1.05);
    }
    
    .theme-preview.active {
      border-color: var(--accent-color);
      box-shadow: 0 0 16px rgba(35, 134, 54, 0.3);
    }
    
    .theme-preview.default {
      background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
      color: #c9d1d9;
    }
    
    .theme-preview.nord {
      background: linear-gradient(135deg, #2e3440 0%, #3b4252 100%);
      color: #eceff4;
    }
    
    .theme-preview.tokyo {
      background: linear-gradient(135deg, #1a1b26 0%, #24283b 100%);
      color: #c0caf5;
    }
    
    .theme-preview.dracula {
  background: linear-gradient(135deg, #282a36 0%, #44475a 100%);
  color: #ff5555;
}

    .theme-preview.everforest {
  background: linear-gradient(135deg, #fdf6e3 0%, #f4f0d9 100%);
  color: #5c6a72;
}

.theme-preview.everforest {
  background: linear-gradient(135deg, #fdf6e3 0%, #f3ead3 100%);
  color: #5c6a72;
}

.theme-preview.onedark {
  background: linear-gradient(135deg, #282c34 0%, #21252b 100%);
  color: #abb2bf;
}

.theme-preview.nord-light {
  background: linear-gradient(135deg, #eceff4 0%, #e5e9f0 100%);
  color: #2e3440;
}

.theme-preview.phoenix {
  background: linear-gradient(135deg, #170f1e 0%, #1c1521 100%);
  color: #f5c2e7;
}

.theme-preview.ereader {
  background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
  color: #000000;
  border: 2px solid #d0d0d0;
}

    .year-display {
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 600;
      padding: 8px 14px;
      display: inline-flex;
      align-items: center;
    }

.google-signin-btn {
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      background: white;
      color: #3c4043;
      border: 1px solid #dadce0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .google-signin-btn:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      background: #f8f9fa;
      border-color: #c6c6c6;
      transform: translateY(-1px);
    }

    .google-signin-btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

.confirm-btn {
  background: var(--border-color);
  border: 1px solid var(--text-secondary);
  color: var(--text-primary);
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.confirm-btn:hover {
  background: var(--text-secondary);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
  transform: translateY(-1px);
}

  </style>
</head>
<body>
  <div class="container">
    <header>
    <h1>Ë™≠Êõ∏</h1>
      <div class="header-actions">
    <div id="authSection"></div>
    <button class="icon-btn" onclick="toggleMenu()" title="Settings">‚öôÔ∏è</button>
  </div>
  <input type="file" id="fileInput" style="display: none;" accept=".json" onchange="loadData(event)">
  <input type="file" id="ttsuInput" style="display: none;" accept=".json" onchange="importTtsuData(event)">
</header>

    <div class="controls">
      <button class="btn" onclick="changeYear(-1)">‚Üê Prev</button>
      <span class="year-display" id="yearDisplay">2026</span>
      <button class="btn" onclick="changeYear(1)">Next ‚Üí</button>
      
      <div class="metric-toggle">
        <button class="metric-option active" id="minutesBtn" onclick="switchMetric('minutes')">Minutes</button>
        <button class="metric-option" id="charactersBtn" onclick="switchMetric('characters')">Characters</button>
      </div>
    </div>

    <div class="heatmap-panel">
      <div class="calendar-wrapper">
        <div class="day-labels">
          <div class="day-label">Mon</div>
          <div class="day-label"></div>
          <div class="day-label">Wed</div>
          <div class="day-label"></div>
          <div class="day-label">Fri</div>
          <div class="day-label"></div>
          <div class="day-label"></div>
        </div>
        <div id="calendar" class="calendar"></div>
      </div>
      
      <div class="stats-section">
        <div class="stats">
          <div class="stat-line" id="stat-longest">
            <span>Longest streak:</span>
            <span class="stat-value" id="longestStreak">0 days</span>
          </div>
          <div class="stat-line" id="stat-current">
            <span>Streak:</span>
            <span class="stat-value" id="currentStreak">0 days</span>
          </div>
          <div class="stat-line" id="stat-average">
            <span>Average:</span>
            <span class="stat-value" id="avgValue">0</span>
          </div>
          <div class="stat-line" id="stat-speed">
            <span>Avg speed:</span>
            <span class="stat-value" id="avgSpeed">0 char/hr</span>
          </div>
          <div class="stat-line" id="stat-total">
            <span>Total:</span>
            <span class="stat-value" id="totalValue">0</span>
          </div>
        </div>
        
        <button class="log-btn" onclick="openModalForToday()">
          Log today ‚Üí
        </button>
      </div>

      <div class="legend">
        <span>Less</span>
        <div class="legend-item" style="background: var(--level-0); border: 1px solid var(--border-color);"></div>
        <div class="legend-item" style="background: var(--level-1);"></div>
        <div class="legend-item" style="background: var(--level-2);"></div>
        <div class="legend-item" style="background: var(--level-3);"></div>
        <div class="legend-item" style="background: var(--level-4);"></div>
        <span>More</span>
      </div>
    </div>
    
    <div class="toggle-buttons">
      <button class="toggle-section-btn" id="goalsToggle" onclick="toggleGoalsSection()">
        üéØ Goals
      </button>
      <button class="toggle-section-btn" id="leaderboardToggle" onclick="toggleLeaderboardSection()">
        üèÜ Leaderboard
      </button>
    </div>
    
    <div class="goals-section" id="goalsSection" style="display: none;">
      <h3 style="margin-bottom: 12px; font-size: 16px;">Goals</h3>
      <div id="goalsList"></div>
      <button class="btn" onclick="addGoal()" style="margin-top: 12px; width: 100%;">+ Add Goal</button>
    </div>
    
    <div class="leaderboard-panel" id="leaderboardPanel" style="display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
    <h2 style="margin: 0;">Leaderboard</h2>
    <select id="leaderboardMetric" onchange="loadLeaderboard()" class="form-input" style="width: auto; padding: 6px 12px; font-size: 13px;">
      <option value="minutes">Total Time</option>
      <option value="characters">Total Characters</option>
      <option value="speed">Avg Speed</option>
    </select>
  </div>
  <div id="leaderboardList"></div>
</div>

  <div class="tooltip" id="tooltip">
    <div class="tooltip-date" id="tooltipDate"></div>
    <div class="tooltip-value" id="tooltipValue"></div>
    <div class="tooltip-titles" id="tooltipTitles"></div>
  </div>

  <div class="modal" id="modal">
    <div class="modal-content">
      <h2>Log reading data</h2>
      <div id="quickLogBooks" class="quick-log-books"></div>
      <div class="form-group">
        <label class="form-label">Date</label>
        <input type="text" class="form-input" id="modalDate" readonly>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Minutes</label>
          <input type="number" class="form-input" id="modalMinutes" min="0" placeholder="60">
        </div>
        <div class="form-group">
          <label class="form-label">Characters</label>
          <input type="number" class="form-input" id="modalCharacters" min="0" placeholder="10000">
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Titles (one per line)</label>
        <textarea class="form-input" id="modalTitles" placeholder="Book title 1
Book title 2"></textarea>
      </div>
      <div class="entry-list" id="entryList"></div>
      <div class="modal-actions">
        <button class="btn" onclick="closeModal()">Cancel</button>
        <button class="log-btn" onclick="saveEntry()">Save</button>
      </div>
    </div>
  </div>

<div class="modal" id="menuModal">
  <div class="modal-content" style="width: 560px; max-width: 95vw;">
    <h2>Quick Settings</h2>
    
    <div style="margin-bottom: 20px;">
      <h3 style="font-size: 14px; margin-bottom: 12px; color: var(--text-secondary);">Theme</h3>
      <div class="theme-selector">
        <div class="theme-preview default" onclick="setTheme('default')">
          <div>GitHub Dark</div>
        </div>
        <div class="theme-preview nord" onclick="setTheme('nord')">
          <div>Nord</div>
        </div>
        <div class="theme-preview tokyo" onclick="setTheme('tokyo')">
          <div>Tokyo Night</div>
        </div>
        <div class="theme-preview dracula" onclick="setTheme('dracula')">
          <div>Dracula</div>
        </div>
        <div class="theme-preview everforest" onclick="setTheme('everforest')">
          <div>Everforest</div>
        </div>
        <div class="theme-preview onedark" onclick="setTheme('onedark')">
          <div>One Dark</div>
        </div>
        <div class="theme-preview nord-light" onclick="setTheme('nord-light')">
          <div>Nord Light</div>
        </div>
        <div class="theme-preview phoenix" onclick="setTheme('phoenix')">
          <div>Phoenix Night</div>
        </div>
        <div class="theme-preview ereader" onclick="setTheme('ereader')">
          <div>E-Reader</div>
        </div>
      </div>
    </div>
    
    <div style="border-top: 1px solid var(--border-color); padding-top: 16px; margin-top: 16px;">
      <a href="settings.html" class="btn" style="width: 100%; display: block; text-align: center; text-decoration: none; margin-bottom: 8px;">‚öôÔ∏è More Settings</a>
      <a href="stats.html" class="btn" style="width: 100%; display: block; text-align: center; text-decoration: none;">üìä View Statistics</a>
    </div>
    
    <button class="btn" onclick="closeMenu()" style="width: 100%; margin-top: 12px;">Close</button>
  </div>
</div>
  
  <div class="modal" id="goalModal">
    <div class="modal-content">
      <h2>Set Goal</h2>
      <div class="form-group">
        <label class="form-label">Goal Type</label>
        <select class="form-input" id="goalType">
          <option value="daily_minutes">Daily Minutes</option>
          <option value="daily_characters">Daily Characters</option>
          <option value="weekly_minutes">Weekly Minutes</option>
          <option value="weekly_characters">Weekly Characters</option>
          <option value="streak">Streak (days)</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Target</label>
        <input type="number" class="form-input" id="goalTarget" min="1" placeholder="60">
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="closeGoalModal()">Cancel</button>
        <button class="log-btn" onclick="saveGoal()">Save Goal</button>
      </div>
    </div>
  </div>
<!-- Stats settings modal -->
<div class="modal" id="statsModal">
  <div class="modal-content" style="max-width: 520px; width: 520px;">
    <h2>Visible Stats Settings</h2>
    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 16px;">
      Choose which statistics to display on the main heatmap panel:
    </p>

    <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px;">
      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color);">
        <input type="checkbox" id="showLongestStreak" onchange="toggleStat('longestStreak')" checked>
        <span style="font-size: 14px;">Longest streak</span>
      </label>

      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color);">
        <input type="checkbox" id="showCurrentStreak" onchange="toggleStat('currentStreak')" checked>
        <span style="font-size: 14px;">Current streak</span>
      </label>

      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color);">
        <input type="checkbox" id="showAverage" onchange="toggleStat('average')" checked>
        <span style="font-size: 14px;">Average</span>
      </label>

      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color);">
        <input type="checkbox" id="showAvgSpeed" onchange="toggleStat('avgSpeed')" checked>
        <span style="font-size: 14px;">Average speed</span>
      </label>

      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; border-radius: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color);">
        <input type="checkbox" id="showTotal" onchange="toggleStat('total')" checked>
        <span style="font-size: 14px;">Total</span>
      </label>
    </div>

    <button class="btn" onclick="closeStatsSettings()" style="width: 100%;">Done</button>
  </div>
</div>


<div class="modal" id="ttsuSyncModal">
  <div class="modal-content">
    <h2>ttsu Google Drive Sync</h2>
    
    <div id="ttsuSyncStatus" style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; padding: 10px; background: var(--bg-secondary); border-radius: 4px;">
      Status: <span id="ttsuSyncStatusText">Not configured</span>
    </div>
   <button class="btn" onclick="setupTtsuSync()" style="width: 100%; margin-bottom: 8px;">
  üîÑ Setup ttsu Auto-Sync
</button>
<button class="btn" onclick="manualSyncTtsu()" style="width: 100%; margin-bottom: 8px;">
  ‚¨áÔ∏è Sync Now
</button>
<button class="btn" onclick="batchLoadAllTtsu()" style="width: 100%; margin-bottom: 8px; background: var(--accent-color); color: white;">
  üì• Batch Load All (Overwrite)
</button>
<button class="btn" onclick="disableTtsuSync()" style="width: 100%; margin-bottom: 8px; opacity: 0.7;">
  ‚ùå Disable Sync
</button>
    
    <button class="btn" onclick="closeTtsuSyncModal()" style="width: 100%; margin-top: 12px;">Close</button>
   </div>
  </div>

<!-- Custom Confirmation Modal -->
<div class="modal" id="confirmModal">
  <div class="modal-content" style="max-width: 500px;">
    <h2 id="confirmTitle">Confirm</h2>
    <p id="confirmMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0;"></p>
    <div class="modal-actions">
      <button class="btn" id="confirmCancel">Cancel</button>
      <button class="confirm-btn" id="confirmOk">OK</button>
    </div>
  </div>
</div>

<!-- Custom Alert Modal -->
<div class="modal" id="alertModal">
  <div class="modal-content" style="max-width: 500px;">
    <h2 id="alertTitle">Notice</h2>
    <p id="alertMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0; white-space: pre-line;"></p>
    <div class="modal-actions">
      <button class="confirm-btn" id="alertOk" style="width: 100%;">OK</button>
    </div>
  </div>
</div>

<!-- Backup Settings Modal -->
<div class="modal" id="backupModal">
  <div class="modal-content" style="max-width: 500px;">
    <h2>Automatic Backup Settings</h2>
    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 16px;">
      Automatically save backup copies of your reading data to protect against data loss.
    </p>
    
    <div class="form-group">
      <label class="form-label">Backup Frequency</label>
      <select class="form-input" id="backupFrequency" onchange="updateBackupFrequency()">
        <option value="none">Disabled</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="monthly">Monthly</option>
      </select>
    </div>
    
    <div class="form-group">
      <label class="form-label">Keep Last</label>
      <select class="form-input" id="backupRetention">
        <option value="3">3 backups</option>
        <option value="5">5 backups</option>
        <option value="10">10 backups</option>
        <option value="20">20 backups</option>
        <option value="all">All backups</option>
      </select>
    </div>
    
    <div id="backupStatus" style="font-size: 13px; color: var(--text-secondary); margin: 16px 0; padding: 10px; background: var(--bg-secondary); border-radius: 4px;">
      Last backup: <span id="lastBackupTime">Never</span>
    </div>
    
    <div style="border-top: 1px solid var(--border-color); padding-top: 16px; margin-top: 16px;">
      <button class="btn" onclick="createManualBackup()" style="width: 100%; margin-bottom: 8px;">üíæ Create Backup Now</button>
      <button class="btn" onclick="viewBackups()" style="width: 100%; margin-bottom: 8px;">üìÇ View & Restore Backups</button>
      <button class="btn" onclick="deleteAllBackups()" style="width: 100%; margin-bottom: 8px; opacity: 0.7;">üóëÔ∏è Delete All Backups</button>
    </div>
    
    <button class="btn" onclick="closeBackupSettings()" style="width: 100%; margin-top: 12px;">Close</button>
  </div>
</div>

<!-- View Backups Modal -->
<div class="modal" id="viewBackupsModal">
  <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
    <h2>Available Backups</h2>
    <div id="backupsList" style="margin-top: 16px;"></div>
    <button class="btn" onclick="closeViewBackups()" style="width: 100%; margin-top: 12px;">Close</button>
  </div>
</div>

  <script>
    const STORAGE_KEY = 'reading_heatmap_data';
    const GOALS_KEY = 'reading_heatmap_goals';
    const BOOKS_KEY = 'reading_heatmap_books';
    const THEME_KEY = 'reading_heatmap_theme';
    const USER_KEY = 'reading_heatmap_user';
    const BACKUP_FREQUENCY_KEY = 'reading_heatmap_backup_frequency';
    const BACKUP_RETENTION_KEY = 'reading_heatmap_backup_retention';
    const LAST_BACKUP_KEY = 'reading_heatmap_last_backup';
    const BACKUPS_KEY = 'reading_heatmap_backups';

    let backupInterval = null;
    
    
    let data = [];
    let dailyData = {};
    let goals = [];
    let recentBooks = [];
    let currentUser = null;
    let currentYear = 2026;
    let googleInitialized = false;

// Confetti animation
    function createConfetti() {
      const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#a29bfe'];
      const confettiCount = 50;
      
      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.style.position = 'fixed';
        confetti.style.width = '10px';
        confetti.style.height = '10px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.top = '-10px';
        confetti.style.opacity = '1';
        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
        confetti.style.zIndex = '10000';
        confetti.style.pointerEvents = 'none';
        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
        
        document.body.appendChild(confetti);
        
        const duration = 3000 + Math.random() * 2000;
        const startTime = Date.now();
        const xMovement = (Math.random() - 0.5) * 200;
        
        function animate() {
          const elapsed = Date.now() - startTime;
          const progress = elapsed / duration;
          
          if (progress < 1) {
            confetti.style.top = (progress * 100 + 10) + 'vh';
            confetti.style.transform = `translateX(${xMovement * Math.sin(progress * Math.PI * 2)}px) rotate(${progress * 720}deg)`;
            confetti.style.opacity = 1 - progress;
            requestAnimationFrame(animate);
          } else {
            confetti.remove();
          }
        }
        
        animate();
      }
    }
  // Stat visibility toggle
    function toggleStat(statName) {
      const statMap = {
        'longestStreak': 'stat-longest',
        'currentStreak': 'stat-current',
        'average': 'stat-average',
        'avgSpeed': 'stat-speed',
        'total': 'stat-total'
      };
      
      const elementId = statMap[statName];
      const checkbox = document.getElementById(`show${statName.charAt(0).toUpperCase() + statName.slice(1)}`);
      const statElement = document.getElementById(elementId);
      
      if (statElement) {
        statElement.style.display = checkbox.checked ? 'flex' : 'none';
      }
      
      // Save preference
      localStorage.setItem(`show_${statName}`, checkbox.checked);
    }
   function openTtsuSyncSettings() {
  const statusText = checkTtsuSyncStatus();
  const el = document.getElementById('ttsuSyncStatusText');
  el.textContent = statusText;
  el.style.color = statusText.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
  document.getElementById('ttsuSyncModal').className = 'modal show';
  closeMenu();
}


function closeTtsuSyncModal() {
  document.getElementById('ttsuSyncModal').className = 'modal';
}
    function loadStatVisibility() {
      const stats = ['longestStreak', 'currentStreak', 'average', 'avgSpeed', 'total'];
      stats.forEach(stat => {
        const saved = localStorage.getItem(`show_${stat}`);
        if (saved !== null) {
          const checkbox = document.getElementById(`show${stat.charAt(0).toUpperCase() + stat.slice(1)}`);
          if (checkbox) {
            checkbox.checked = saved === 'true';
            toggleStat(stat);
          }
        }
      });
    }
  
window.onload = function() {
  loadTheme();
  loadStatVisibility();
    
  window.data = data = [];
  window.dailyData = dailyData = {};
  window.goals = goals = [];
  window.recentBooks = recentBooks = [];
  window.currentUser = currentUser = null;
  
  // Check if there's a stored user (for faster UI update)
  const storedUser = localStorage.getItem(USER_KEY);
  if (storedUser) {
    try {
      window.currentUser = currentUser = JSON.parse(storedUser);
    } catch (e) {
      console.error('Error loading stored user:', e);
    }
  }
  
  initializeAuthButton();
  renderHeatmap();
  updateStats();
  
  // Initialize automatic backups
  initializeBackups();
  
  // Warn if not running on server
  if (window.location.protocol === 'file:') {
    setTimeout(async () => {
      await customAlert("Warning: Google Sign-In will NOT work if you open this file directly.\n\nPlease use a local server (e.g., Live Server in VS Code).", 'Warning');
    }, 500);
  }
};

function initializeAuthButton() {
  var el = document.getElementById('authSection');
  if (!el) return;
  
  if (window.currentUser) {
    renderUserProfile();
  } else {
    el.innerHTML = '<button class="google-signin-btn" onclick="promptSignIn()">' +
      '<svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">' +
      '<path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>' +
      '<path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>' +
      '<path fill="#FBBC05" d="M3.964 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.347 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.007-2.332z"/>' +
      '<path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z"/>' +
      '</svg>' +
      'Sign in with Google' +
      '</button>';
  }
}

// Make initializeAuthButton globally available for Firebase to call
window.initializeAuthButton = initializeAuthButton;

// Fallback prompt-based sign-in if Google OAuth not configured
async function promptSignIn() {
  // Try Firebase sign-in first
  if (window.promptSignIn && typeof window.firebaseSignIn === 'function') {
    window.firebaseSignIn();
    return;
  }
  
  // Fallback to manual sign-in
  const name = await customPrompt('Enter your name:', 'Sign In');
  if (!name) return;
  
  const email = await customPrompt('Enter your email (optional):', 'Email (Optional)') || 'user@example.com';
  
  currentUser = {
    id: Date.now().toString(),
    name: name,
    email: email,
    avatar: `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random&size=128`
  };
  
  localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
  renderUserProfile();
  updateLeaderboard();
  await customAlert('Welcome, ' + name + '! You can now use the leaderboard.', 'Welcome');
}

async function signOut() {
  const confirmed = await customConfirm(
    'Sign out of your account?',
    'Sign Out'
  );
  
  if (!confirmed) return;
  
  if (window.firebaseSignOut && typeof window.firebaseSignOut === 'function') {
    window.firebaseSignOut();
  } else {
    // Fallback for manual sign-in users
    window.currentUser = null;
    currentUser = null;
    localStorage.removeItem(USER_KEY);
    initializeAuthButton();
  }
} 

    function renderUserProfile() {
      const authSection = document.getElementById('authSection');
      // Use window.currentUser instead of currentUser to ensure we're reading the global variable
      if (window.currentUser) {
        authSection.innerHTML = `
          <div class="user-profile" onclick="signOut()" title="Click to sign out">
            <img src="${window.currentUser.avatar}" class="user-avatar" alt="${window.currentUser.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22 fill=%22%23888%22/%3E%3C/svg%3E'">
            <span class="user-name">${window.currentUser.name}</span>
          </div>
        `;
      }
    }
    
    // Make renderUserProfile globally available for Firebase to call
    window.renderUserProfile = renderUserProfile;
    
async function exportToToggl() {
  const togglData = data.map(entry => ({
    description: entry.title || 'Reading',
    start: `${entry.date}T00:00:00Z`,
    duration: entry.minutes * 60,
    tags: ['reading'],
    created_with: 'Reading Heatmap'
  }));
  
  const blob = new Blob([JSON.stringify(togglData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'reading-toggl-export.json';
  a.click();
  URL.revokeObjectURL(url);
  
  await customAlert('Exported to Toggl format! Import this file to Toggl Track.', 'Export Successful');
  closeMenu();
}

    function getAustralianDate() {
      const now = new Date();
      const australiaTime = new Date(now.toLocaleString('en-US', { timeZone: 'Australia/Sydney' }));
      return australiaTime.toISOString().split('T')[0];
    }

   async function loadFromStorage() {
  // Only load from cloud storage when user is signed in
  if (!window.currentUser && !currentUser) {
    window.data = data = [];
    window.dailyData = dailyData = {};
    window.goals = goals = [];
    window.recentBooks = recentBooks = [];
    aggregateData();
    loadYear();
    renderGoals();
    return;
  }
  
  // Data is loaded from Firebase in firebaseSignIn
  // This function just refreshes the UI
  aggregateData();
  loadYear();
  renderGoals();
}

    async function saveToStorage() {
  // Don't save to localStorage anymore - only cloud
  // The Firebase hooks will handle cloud saves
  
  try {
    localStorage.setItem('reading_heatmap_sync_signal', Date.now().toString());
  } catch (e) {}
}

    function aggregateData() {
  window.dailyData = dailyData = {};
  const dataArray = window.data || data || [];
  dataArray.forEach(item => {
    if (!dailyData[item.date]) {
      dailyData[item.date] = { minutes: 0, characters: 0, titles: [] };
    }
    dailyData[item.date].minutes += item.minutes;
    dailyData[item.date].characters += item.characters;
    if (item.title && !dailyData[item.date].titles.includes(item.title)) {
      dailyData[item.date].titles.push(item.title);
    }
  });
  window.dailyData = dailyData;
}

    function loadYear() {
      document.getElementById('yearDisplay').textContent = currentYear;
      renderHeatmap();
      updateStats();
    }

    function changeYear(delta) {
      currentYear = currentYear + delta;
      loadYear();
    }

    function switchMetric(metric) {
      document.getElementById('minutesBtn').classList.toggle('active', metric === 'minutes');
      document.getElementById('charactersBtn').classList.toggle('active', metric === 'characters');
      
      localStorage.setItem('selectedMetric', metric);
      renderHeatmap();
      updateStats();
    }

    function getSelectedMetric() {
      const stored = localStorage.getItem('selectedMetric');
      return stored || 'minutes';
    }

    function renderHeatmap() {
      const year = currentYear;
      const metric = getSelectedMetric();
      const calendar = document.getElementById('calendar');
      calendar.innerHTML = '';

      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      const startDate = new Date(year, 0, 1);
      const endDate = new Date(year, 11, 31);
      
      let currentDate = new Date(startDate);
      let currentMonth = -1;
      let weekDiv = null;
      let monthDiv = null;
      
      // Get the day of week for Jan 1 (0=Sun, 1=Mon, 6=Sat)
const startDay = startDate.getDay();
// Convert to Monday-based (Mon=0, Sun=6)
const startDayMonday = startDay === 0 ? 6 : startDay - 1;
let isFirstWeek = true;

while (currentDate <= endDate) {
  const dayOfWeek = currentDate.getDay();
  const dayOfWeekMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  
  // Start a new week on Monday
  if (dayOfWeekMonday === 0 || !weekDiv) {
    if (weekDiv && monthDiv) {
      const weeksContainer = monthDiv.querySelector('.weeks');
      if (weeksContainer) {
        weeksContainer.appendChild(weekDiv);
      }
    }
    
    weekDiv = document.createElement('div');
    weekDiv.className = 'week';
    
    // Add offset for the first week to align with day labels
    if (isFirstWeek && startDayMonday > 0) {
      weekDiv.style.paddingTop = `calc(${startDayMonday} * (14px + 5px))`;
      isFirstWeek = false;
    }
  }
        
        const month = currentDate.getMonth();
        if (month !== currentMonth) {
          currentMonth = month;
          monthDiv = document.createElement('div');
          monthDiv.className = 'month';
          
          const label = document.createElement('div');
          label.className = 'month-label';
          label.textContent = months[month];
          monthDiv.appendChild(label);
          
          const weeksContainer = document.createElement('div');
          weeksContainer.className = 'weeks';
          monthDiv.appendChild(weeksContainer);
          
          calendar.appendChild(monthDiv);
        }
        
        const dayDiv = document.createElement('div');
        dayDiv.className = 'day';
        
        const dateStr = currentDate.toISOString().split('T')[0];
        const today = getAustralianDate();
        
        if (dateStr === today) {
          dayDiv.classList.add('today');
        }
        
        const dayData = dailyData[dateStr];
        
        if (dayData) {
          const value = dayData[metric];
          const level = getLevel(value, metric);
          dayDiv.className += ` level-${level}`;
        } else {
          dayDiv.className += ' empty';
        }
        
        dayDiv.dataset.date = dateStr;
        dayDiv.addEventListener('mouseenter', showTooltip);
        dayDiv.addEventListener('mouseleave', hideTooltip);
        dayDiv.addEventListener('click', () => openModal(dateStr));
        
        weekDiv.appendChild(dayDiv);
        
        if (dayOfWeekMonday === 6) {
          const weeksContainer = monthDiv.querySelector('.weeks');
          if (weeksContainer) {
            weeksContainer.appendChild(weekDiv);
          }
          weekDiv = null;
        }
        
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      if (weekDiv && monthDiv) {
        const weeksContainer = monthDiv.querySelector('.weeks');
        if (weeksContainer) {
          weeksContainer.appendChild(weekDiv);
        }
      }
    }

    function getLevel(value, metric) {
      if (value === 0) return 0;
      const thresholds = metric === 'minutes' 
        ? [1, 30, 60, 90] 
        : [1, 3000, 6000, 10000];
      
      for (let i = thresholds.length - 1; i >= 0; i--) {
        if (value >= thresholds[i]) return i + 1;
      }
      return 1;
    }

    function showTooltip(e) {
      const tooltip = document.getElementById('tooltip');
      const dateStr = e.target.dataset.date;
      const dayData = dailyData[dateStr] || { minutes: 0, characters: 0, titles: [] };
      const metric = getSelectedMetric();
      
      const date = new Date(dateStr + 'T00:00:00');
      document.getElementById('tooltipDate').textContent = 
        date.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
      
      const value = dayData[metric];
      document.getElementById('tooltipValue').textContent = 
        metric === 'minutes' 
          ? `${value} minutes reading`
          : `${value.toLocaleString()} characters`;
      
      const titlesDiv = document.getElementById('tooltipTitles');
      if (dayData.titles.length > 0) {
        titlesDiv.style.display = 'block';
        titlesDiv.textContent = dayData.titles.join(', ');
      } else {
        titlesDiv.style.display = 'none';
      }
      
      tooltip.className = 'tooltip show';
      
      const rect = e.target.getBoundingClientRect();
      tooltip.style.left = (rect.left + rect.width / 2) + 'px';
      tooltip.style.top = (rect.top - 10) + 'px';
      tooltip.style.transform = 'translate(-50%, -100%)';
    }

    function hideTooltip() {
      document.getElementById('tooltip').className = 'tooltip';
    }

function updateStats() {
  const year = currentYear;
  const metric = getSelectedMetric();
  
  let longestStreak = 0, currentStreak = 0, streak = 0;
  let total = 0, count = 0;
  
  const startDate = new Date(year, 0, 1);
  const endDate = new Date(year, 11, 31);
  const today = new Date();
  
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split('T')[0];
    const dayData = dailyData[dateStr];
    const value = dayData ? dayData[metric] : 0;
    
    total += value;
    count++;
    
    if (value > 0) {
      streak++;
      longestStreak = Math.max(longestStreak, streak);
    } else {
      streak = 0;
    }
  }
  
  streak = 0;
  for (let d = new Date(today); d.getFullYear() === year; d.setDate(d.getDate() - 1)) {
    const dateStr = d.toISOString().split('T')[0];
    const dayData = dailyData[dateStr];
    if (dayData && dayData[metric] > 0) {
      streak++;
    } else {
      break;
    }
  }
  currentStreak = streak;

  // Calculate average reading speed (characters per hour)
  // Only include days that have characters > 0 to avoid skew by time-only entries

  // Global (all-time) avg speed over dailyData
  let globalMinutesWithChars = 0;
  let globalCharactersWithChars = 0;

  Object.entries(dailyData).forEach(([dateStr, day]) => {
    const hasChars = (day.characters || 0) > 0;
    if (hasChars) {
      globalMinutesWithChars += day.minutes || 0;
      globalCharactersWithChars += day.characters || 0;
    }
  });

  const globalHoursWithChars = globalMinutesWithChars / 60;
  const globalAvgSpeed = globalHoursWithChars > 0
    ? Math.round(globalCharactersWithChars / globalHoursWithChars)
    : 0;

  // Year-scoped avg speed for currentYear
  let yearMinutesWithChars = 0;
  let yearCharactersWithChars = 0;

  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split('T')[0];
    const day = dailyData[dateStr];
    if (!day) continue;
    const hasChars = (day.characters || 0) > 0;
    if (hasChars) {
      yearMinutesWithChars += day.minutes || 0;
      yearCharactersWithChars += day.characters || 0;
    }
  }

  const yearHoursWithChars = yearMinutesWithChars / 60;
  const yearAvgSpeed = yearHoursWithChars > 0
    ? Math.round(yearCharactersWithChars / yearHoursWithChars)
    : 0;

  // Display the year average speed in the UI (preferred)
  document.getElementById('avgSpeed').textContent = yearAvgSpeed.toLocaleString() + ' char/hr';
  // If you want to display the global instead, swap to:
  // document.getElementById('avgSpeed').textContent = globalAvgSpeed.toLocaleString() + ' char/hr';

  // Calculate average only from first logged day
  let firstLoggedDate = null;
  Object.keys(dailyData).forEach(dateStr => {
    if (!firstLoggedDate || dateStr < firstLoggedDate) {
      firstLoggedDate = dateStr;
    }
  });

  let daysToCount = 0;
  if (firstLoggedDate) {
    for (let d = new Date(firstLoggedDate + 'T00:00:00'); d <= endDate && d <= new Date(); d.setDate(d.getDate() + 1)) {
      daysToCount++;
    }
  }

  const avg = daysToCount > 0 ? total / daysToCount : 0;
  const suffix = metric === 'minutes' ? ' minutes' : ' characters';
  
  document.getElementById('longestStreak').textContent = `${longestStreak} days`;
  document.getElementById('currentStreak').textContent = `${currentStreak} days`;
  document.getElementById('avgValue').textContent = Math.round(avg).toLocaleString() + suffix;
  document.getElementById('totalValue').textContent = Math.round(total).toLocaleString() + suffix;
}


    function openModal(dateStr) {
      const modal = document.getElementById('modal');
      const dayData = dailyData[dateStr] || { minutes: 0, characters: 0, titles: [] };
      
      document.getElementById('modalDate').value = dateStr;
      document.getElementById('modalMinutes').value = dayData.minutes || '';
      document.getElementById('modalCharacters').value = dayData.characters || '';
      document.getElementById('modalTitles').value = dayData.titles.join('\n');
      
      renderQuickLogBooks();
      renderEntryList(dateStr);
      
      modal.className = 'modal show';
    }
    
    function renderQuickLogBooks() {
      const container = document.getElementById('quickLogBooks');
      if (recentBooks.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      container.innerHTML = '';
      recentBooks.slice(0, 3).forEach(book => {
        const btn = document.createElement('button');
        btn.className = 'quick-book-btn';
        btn.textContent = book;
        btn.onclick = () => {
          const currentTitles = document.getElementById('modalTitles').value;
          if (!currentTitles.includes(book)) {
            document.getElementById('modalTitles').value = currentTitles ? currentTitles + '\n' + book : book;
          }
          btn.classList.add('active');
          setTimeout(() => btn.classList.remove('active'), 300);
        };
        container.appendChild(btn);
      });
    }

    function openModalForToday() {
      const today = getAustralianDate();
      openModal(today);
    }

    function closeModal() {
      document.getElementById('modal').className = 'modal';
    }

    function renderEntryList(dateStr) {
      const entryList = document.getElementById('entryList');
      const dateEntries = data.filter(item => item.date === dateStr);
      
      if (dateEntries.length === 0) {
        entryList.innerHTML = '';
        return;
      }
      
      entryList.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">Entries for this date:</div>';
      
      dateEntries.forEach((entry, index) => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'entry-item';
        
        let content = '';
        if (entry.title) {
          content = `<strong>${entry.title}</strong>`;
          if (entry.minutes > 0 || entry.characters > 0) {
            content += `<br><span class="entry-detail">${entry.minutes} min, ${entry.characters.toLocaleString()} chars</span>`;
          }
        } else {
          content = `<strong>${entry.minutes} min</strong><br><span class="entry-detail">${entry.characters.toLocaleString()} characters</span>`;
        }
        
        entryDiv.innerHTML = `
          <div class="entry-info">${content}</div>
          <button class="delete-btn" onclick="deleteEntry('${dateStr}', ${index})">Delete</button>
        `;
        
        entryList.appendChild(entryDiv);
      });
    }

    async function deleteEntry(dateStr, index) {
  const dateEntries = window.data.filter(item => item.date === dateStr);
  if (dateEntries[index]) {
    const entryToDelete = dateEntries[index];
    window.data = window.data.filter(item => !(item.date === dateStr && 
      item.minutes === entryToDelete.minutes && 
      item.characters === entryToDelete.characters && 
      item.title === entryToDelete.title));
    
    // Sync with local variable
    data = window.data;
    
    await saveToStorage();
    aggregateData();
    renderEntryList(dateStr);
    loadYear();
    
    // Trigger cloud save if available
    if (window.saveCloudState && typeof window.saveCloudState === 'function') {
      await window.saveCloudState();
    }
  }
}

    async function saveEntry() {
  const dateStr = document.getElementById('modalDate').value;
  const minutes = parseInt(document.getElementById('modalMinutes').value) || 0;
  const characters = parseInt(document.getElementById('modalCharacters').value) || 0;
  const titles = document.getElementById('modalTitles').value
    .split('\n')
    .map(t => t.trim())
    .filter(Boolean);
  
  titles.forEach(title => {
    if (!recentBooks.includes(title)) {
      recentBooks.unshift(title);
      recentBooks = recentBooks.slice(0, 10);
    }
  });
  
  // Update both local and window variables
  window.recentBooks = recentBooks;
  
  data = data.filter(item => item.date !== dateStr);
  
  if (titles.length > 0) {
    data.push({ date: dateStr, minutes, characters, title: titles[0] });
    titles.slice(1).forEach(title => {
      data.push({ date: dateStr, minutes: 0, characters: 0, title });
    });
  } else {
    data.push({ date: dateStr, minutes, characters, title: null });
  }
  
  // Sync with window
  window.data = data;
  
  await saveToStorage();
  aggregateData();
  loadYear();
  renderGoals();
  closeModal();
  
  // Trigger cloud save if available
  if (window.saveCloudState && typeof window.saveCloudState === 'function') {
    await window.saveCloudState();
  }
}

    function downloadData() {
      const exportData = {
        data: window.data || [],
        goals: window.goals || [],
        recentBooks: window.recentBooks || [],
        exportDate: new Date().toISOString(),
        user: window.currentUser ? {
          name: window.currentUser.name,
          email: window.currentUser.email
        } : null
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `reading-heatmap-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      closeMenu();
    }
async function loadData(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const imported = JSON.parse(e.target.result);
      
      let importedData = [];
      let importedGoals = [];
      let importedBooks = [];
      
      if (Array.isArray(imported)) {
        importedData = imported;
      } else if (imported.data) {
        importedData = imported.data || [];
        importedGoals = imported.goals || [];
        importedBooks = imported.recentBooks || [];
      } else {
        await customAlert('Invalid data format.', 'Invalid File');
        return;
      }
      
      if (importedData.length > 0) {
        const replace = await customConfirm(
          'Replace existing data?\n\nClick OK to replace, or Cancel to merge with existing data.',
          'Import Data'
        );
        
        if (replace) {
          window.data = importedData;
          window.goals = importedGoals;
          window.recentBooks = importedBooks;
        } else {
          window.data = [...window.data, ...importedData];
          window.goals = [...window.goals, ...importedGoals];
          window.recentBooks = [...new Set([...window.recentBooks, ...importedBooks])];
        }
      }
      
      // Sync with local variables
      data = window.data;
      goals = window.goals;
      recentBooks = window.recentBooks;
      
      await saveToStorage();
      aggregateData();
      loadYear();
      renderGoals();
      
      if (window.saveCloudState && typeof window.saveCloudState === 'function') {
        await window.saveCloudState();
      }
      
      closeMenu();
      await customAlert('Data loaded successfully!', 'Import Successful');
    } catch (error) {
      await customAlert('Error reading file: ' + error.message, 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = '';
}

    function toggleMenu() {
      const modal = document.getElementById('menuModal');
      modal.className = 'modal show';
      updateThemeSelection();
    }

    function closeMenu() {
      document.getElementById('menuModal').className = 'modal';
    }

async function wipeAllData() {
  const firstConfirm = await customConfirm(
    'Are you sure? This will permanently delete all data. This action cannot be undone.',
    'Wipe All Data'
  );
  
  if (!firstConfirm) return;
  
  const secondConfirm = await customConfirm(
    'Really delete ALL data? Click OK to confirm.',
    'Final Confirmation'
  );
  
  if (!secondConfirm) return;
  
  data = [];
  dailyData = {};
  goals = [];
  recentBooks = [];
  await saveToStorage();
  loadYear();
  renderGoals();
  closeMenu();
  await customAlert('All data has been wiped.', 'Data Wiped');
}

    document.getElementById('statsModal').addEventListener('click', (e) => {
  if (e.target.id === 'statsModal') closeStatsSettings();
});
document.getElementById('backupModal').addEventListener('click', (e) => {
  if (e.target.id === 'backupModal') closeBackupSettings();
});

document.getElementById('viewBackupsModal').addEventListener('click', (e) => {
  if (e.target.id === 'viewBackupsModal') closeViewBackups();
});
    document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' || e.key === 'Esc') {
    // Don't close modals if custom confirm/alert is open
    if (document.getElementById('confirmModal').classList.contains('show') ||
        document.getElementById('alertModal').classList.contains('show')) {
      return;
    }
    
    try { closeBackupSettings(); } catch (err) {}
    try { closeViewBackups(); } catch (err) {}
    try { hideTooltip(); } catch (err) {}
    try { closeModal(); } catch (err) {}
    try { closeMenu(); } catch (err) {}
    try { closeGoalModal(); } catch (err) {}
    try { closeStatsSettings(); } catch (err) {}
    try { closeTtsuSyncModal(); } catch (err) {}

    try {
      const active = document.activeElement;
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'BUTTON' || active.isContentEditable)) {
        active.blur();
      }
    } catch (err) {}
  }
});

    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });
    document.getElementById('menuModal').addEventListener('click', (e) => {
      if (e.target.id === 'menuModal') closeMenu();
    }); // Close when clicking outside modal-content (ttsu settings)
document.getElementById('ttsuSyncModal').addEventListener('click', (e) => {
  if (e.target.id === 'ttsuSyncModal') {
    closeTtsuSyncModal();
  }
});

    function loadTheme() {
      const theme = localStorage.getItem(THEME_KEY) || 'default';
      setTheme(theme, false);
    }
    
    function setTheme(theme, save = true) {
      document.body.className = theme === 'default' ? '' : `theme-${theme}`;
      if (save) {
        localStorage.setItem(THEME_KEY, theme);
        updateThemeSelection();
      }
    }
    
    function updateThemeSelection() {
      const currentTheme = localStorage.getItem(THEME_KEY) || 'default';
      document.querySelectorAll('.theme-preview').forEach(el => {
        const themeClass = el.className.split(' ').find(c => c !== 'theme-preview' && c !== 'active');
        if (themeClass === currentTheme) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }
    
    function toggleGoalsSection() {
      const section = document.getElementById('goalsSection');
      const btn = document.getElementById('goalsToggle');
      const isVisible = section.style.display !== 'none';
      
      section.style.display = isVisible ? 'none' : 'block';
      btn.classList.toggle('active', !isVisible);
    }
    
    function addGoal() {
      document.getElementById('goalModal').className = 'modal show';
    }
    
    function closeGoalModal() {
      document.getElementById('goalModal').className = 'modal';
    }
function openStatsSettings() {
  document.getElementById('statsModal').className = 'modal show';
}

function closeStatsSettings() {
  document.getElementById('statsModal').className = 'modal';
}
async function saveGoal() {
  const type = document.getElementById('goalType').value;
  const target = parseInt(document.getElementById('goalTarget').value);
  
  if (!target || target <= 0) {
    await customAlert('Please enter a valid target', 'Invalid Target');
    return;
  }
  
  goals.push({ type, target, id: Date.now() });
  window.goals = goals;
  
  await saveToStorage();
  renderGoals();
  closeGoalModal();
  
  document.getElementById('goalTarget').value = '';
  
  // Trigger cloud save if available
  if (window.saveCloudState && typeof window.saveCloudState === 'function') {
    await window.saveCloudState();
  }
}    

    function renderGoals() {
      const container = document.getElementById('goalsList');
      if (goals.length === 0) {
        container.innerHTML = '<div style="color: var(--text-secondary); font-size: 13px;">No goals set yet</div>';
        return;
      }
      
      container.innerHTML = '';
      goals.forEach(goal => {
        const progress = calculateGoalProgress(goal);
        const goalDiv = document.createElement('div');
        goalDiv.className = 'goal-item';
        
        const typeText = {
          daily_minutes: 'Daily Minutes',
          daily_characters: 'Daily Characters',
          weekly_minutes: 'Weekly Minutes',
          weekly_characters: 'Weekly Characters',
          streak: 'Streak Days'
        }[goal.type];
        
        const isAchieved = progress.current >= goal.target;
const wasAchievedBefore = goal.wasAchieved || false;
const achievedStyle = isAchieved ? 'background: var(--accent-color); color: #ffffff; border-radius: 6px; padding: 8px;' : '';

// Trigger confetti if newly achieved
if (isAchieved && !wasAchievedBefore) {
  goal.wasAchieved = true;
  setTimeout(() => createConfetti(), 100);
}

goalDiv.innerHTML = `
  <div style="flex: 1; ${achievedStyle}">
    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; align-items: center;">
      <span>${typeText}: ${goal.target} ${isAchieved ? 'üéâ' : ''}</span>
      <span style="color: ${isAchieved ? '#ffffff' : 'var(--accent-color)'}; font-weight: 600;">${progress.current} / ${goal.target}</span>
    </div>
    ${isAchieved ? '<div style="font-size: 12px; margin-top: 4px;">üéä Congratulations! Goal achieved! üéä</div>' : ''}
    <div class="goal-progress">
      <div class="goal-progress-bar" style="width: ${Math.min(100, (progress.current / goal.target) * 100)}%"></div>
    </div>
  </div>
  <button class="delete-btn" onclick="deleteGoal(${goal.id})">Delete</button>
`;

container.appendChild(goalDiv);
      });
    }
    
    function calculateGoalProgress(goal) {
      const today = getAustralianDate();
      const metric = goal.type.includes('minutes') ? 'minutes' : goal.type.includes('characters') ? 'characters' : 'streak';
      
      if (goal.type.startsWith('daily')) {
        const dayData = dailyData[today];
        return { current: dayData ? dayData[metric] : 0, target: goal.target };
      } else if (goal.type.startsWith('weekly')) {
        let total = 0;
        const now = new Date(today);
        for (let i = 0; i < 7; i++) {
          const d = new Date(now);
          d.setDate(d.getDate() - i);
          const dateStr = d.toISOString().split('T')[0];
          const dayData = dailyData[dateStr];
          if (dayData) total += dayData[metric];
        }
        return { current: total, target: goal.target };
      } else if (goal.type === 'streak') {
        let streak = 0;
        const now = new Date(today);
        for (let i = 0; i < 365; i++) {
          const d = new Date(now);
          d.setDate(d.getDate() - i);
          const dateStr = d.toISOString().split('T')[0];
          const dayData = dailyData[dateStr];
          if (dayData && (dayData.minutes > 0 || dayData.characters > 0)) {
            streak++;
          } else {
            break;
          }
        }
        return { current: streak, target: goal.target };
      }
      return { current: 0, target: goal.target };
    }
    
async function deleteGoal(id) {
  goals = goals.filter(g => g.id !== id);
  window.goals = goals;
  
  await saveToStorage();
  renderGoals();
  
  // Trigger cloud save if available
  if (window.saveCloudState && typeof window.saveCloudState === 'function') {
    await window.saveCloudState();
  }
}
    
    function toggleLeaderboardSection() {
      const panel = document.getElementById('leaderboardPanel');
      const btn = document.getElementById('leaderboardToggle');
      const isVisible = panel.style.display !== 'none';
      
      panel.style.display = isVisible ? 'none' : 'block';
      btn.classList.toggle('active', !isVisible);
      
      if (!isVisible) {
        loadLeaderboard();
      }
    }
    
  async function loadLeaderboard() {
  const container = document.getElementById('leaderboardList');
  
  if (!currentUser && !window.currentUser) {
    container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Sign in to view the leaderboard and compete with others!</div>';
    return;
  }
  
  try {
    // Check if saveCloudState exists (means Firebase is loaded)
    if (!window.saveCloudState) {
      container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Firebase is loading... Please try again in a moment.</div>';
      return;
    }

    // Use the global loadLeaderboardData function from Firebase module
    if (window.loadLeaderboardData) {
      await window.loadLeaderboardData();
    } else {
      container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Leaderboard not available. Please refresh the page.</div>';
    }
    
  } catch (error) {
    container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Failed to load leaderboard data.</div>';
    console.error('Leaderboard error:', error);
  }
}
// Make all functions globally available
    window.aggregateData = aggregateData;
    window.loadYear = loadYear;
    window.renderGoals = renderGoals;
    window.renderUserProfile = renderUserProfile;
    window.initializeAuthButton = initializeAuthButton;
    window.loadFromStorage = loadFromStorage;
    window.saveEntry = saveEntry;
    window.deleteEntry = deleteEntry;
    window.saveGoal = saveGoal;
    window.deleteGoal = deleteGoal;
    window.wipeAllData = wipeAllData;
    
    // Sync all variables with window
    window.data = data;
    window.dailyData = dailyData;
    window.goals = goals;
    window.recentBooks = recentBooks;
    window.currentUser = currentUser;
    window.currentYear = currentYear;

// Add this to your HTML (in the settings modal after the other buttons):
/*
<input type="file" id="ttsuInput" style="display: none;" accept=".json" onchange="importTtsuData(event)">
<button class="btn" onclick="document.getElementById('ttsuInput').click()" style="width: 100%; margin-bottom: 8px;">
  üìö Import from ttsu
</button>
*/

// Updated function to handle the ACTUAL ttsu export format
async function importTtsuData(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const ttsuData = JSON.parse(e.target.result);
      
      console.log('ttsu data structure:', ttsuData);
      
      if (!Array.isArray(ttsuData)) {
        await customAlert('Invalid ttsu export format. Expected an array of reading sessions.', 'Invalid Format');
        return;
      }
      
      const transformedData = [];
      let importedCount = 0;
      const bookTitles = new Set();
      
      // ttsu exports an array of sessions with this structure:
      // { title, dateKey, charactersRead, readingTime (in seconds), ... }
      
      ttsuData.forEach(session => {
        // Skip sessions with no actual reading data
        if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
          return;
        }
        
        // Convert dateKey from "2025-11-23" format to ISO date
        const date = session.dateKey;
        
        // Convert readingTime from seconds to minutes
        const minutes = Math.round(session.readingTime / 60);
        const characters = session.charactersRead || 0;
        
        // Skip if no meaningful data
        if (minutes === 0 && characters === 0) {
          return;
        }
        
        // Check if this exact entry already exists (same date, title, and similar values)
        const exists = window.data.some(entry => 
          entry.date === date && 
          entry.title === session.title &&
          Math.abs(entry.minutes - minutes) < 2 && // Allow 2 min difference
          Math.abs(entry.characters - characters) < 100 // Allow 100 char difference
        );
        
        if (!exists) {
          transformedData.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || 'Reading (from ttsu)'
          });
          importedCount++;
          bookTitles.add(session.title);
        }
      });
      
      if (transformedData.length === 0) {
        await customAlert('No new reading data found in ttsu export.\n\nAll sessions have either already been imported or contain no reading data.');
        return;
      }
      
      // Merge with existing data
      window.data = [...window.data, ...transformedData];
      data = window.data;
      
      // Add book titles to recent books
      bookTitles.forEach(title => {
        if (title && !window.recentBooks.includes(title)) {
          window.recentBooks.unshift(title);
        }
      });
      window.recentBooks = window.recentBooks.slice(0, 10);
      recentBooks = window.recentBooks;
      
      // Save and update UI
      await saveToStorage();
      aggregateData();
      loadYear();
      renderGoals();
      
      // Trigger cloud save if available
      if (window.saveCloudState && typeof window.saveCloudState === 'function') {
        await window.saveCloudState();
      }
      
      closeMenu();
      
      const bookList = Array.from(bookTitles).join(', ');
      await customAlert(
  `‚úÖ Successfully imported ${importedCount} reading session(s) from ttsu!\n\nBooks: ${bookList}\n\nYour heatmap has been updated.`,
  'Import Successful'
);
      
    } catch (error) {
      console.error('Import error:', error);
      await customAlert('Error importing ttsu data: ' + error.message + '\n\nPlease make sure you exported the correct JSON file from ttsu.', 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = ''; // Reset file input
}
 
// Custom themed confirm dialog
function customConfirm(message, title = 'Confirm') {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    const titleEl = document.getElementById('confirmTitle');
    const messageEl = document.getElementById('confirmMessage');
    const okBtn = document.getElementById('confirmOk');
    const cancelBtn = document.getElementById('confirmCancel');
    
    titleEl.textContent = title;
    messageEl.textContent = message;
    modal.className = 'modal show';
    
    const handleOk = () => {
      cleanup();
      resolve(true);
    };
    
    const handleCancel = () => {
      cleanup();
      resolve(false);
    };
    
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        cleanup();
        resolve(false);
      }
    };
    
    const cleanup = () => {
      modal.className = 'modal';
      okBtn.removeEventListener('click', handleOk);
      cancelBtn.removeEventListener('click', handleCancel);
      document.removeEventListener('keydown', handleEscape);
    };
    
    okBtn.addEventListener('click', handleOk);
    cancelBtn.addEventListener('click', handleCancel);
    document.addEventListener('keydown', handleEscape);
  });
}

// Custom themed alert dialog
function customAlert(message, title = 'Notice') {
  return new Promise((resolve) => {
    const modal = document.getElementById('alertModal');
    const titleEl = document.getElementById('alertTitle');
    const messageEl = document.getElementById('alertMessage');
    const okBtn = document.getElementById('alertOk');
    
    titleEl.textContent = title;
    messageEl.textContent = message;
    modal.className = 'modal show';
    
    const handleOk = () => {
      cleanup();
      resolve();
    };
    
    const handleEscape = (e) => {
      if (e.key === 'Escape' || e.key === 'Enter') {
        cleanup();
        resolve();
      }
    };
    
    const cleanup = () => {
      modal.className = 'modal';
      okBtn.removeEventListener('click', handleOk);
      document.removeEventListener('keydown', handleEscape);
    };
    
    okBtn.addEventListener('click', handleOk);
    document.addEventListener('keydown', handleEscape);
    
    // Auto-focus OK button
    setTimeout(() => okBtn.focus(), 100);
  });
}
 
 // Custom themed prompt dialog
function customPrompt(message, title = 'Input') {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    const titleEl = document.getElementById('confirmTitle');
    const messageEl = document.getElementById('confirmMessage');
    const okBtn = document.getElementById('confirmOk');
    const cancelBtn = document.getElementById('confirmCancel');
    
    titleEl.textContent = title;
    
    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'form-input';
    input.style.marginTop = '12px';
    input.placeholder = message;
    
    messageEl.textContent = message;
    messageEl.appendChild(document.createElement('br'));
    messageEl.appendChild(input);
    
    modal.className = 'modal show';
    
    setTimeout(() => input.focus(), 100);
    
    const handleOk = () => {
      const value = input.value.trim();
      cleanup();
      resolve(value);
    };
    
    const handleCancel = () => {
      cleanup();
      resolve(null);
    };
    
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        cleanup();
        resolve(null);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        handleOk();
      }
    };
    
    const cleanup = () => {
      modal.className = 'modal';
      messageEl.textContent = '';
      okBtn.removeEventListener('click', handleOk);
      cancelBtn.removeEventListener('click', handleCancel);
      document.removeEventListener('keydown', handleEscape);
    };
    
    okBtn.addEventListener('click', handleOk);
    cancelBtn.addEventListener('click', handleCancel);
    document.addEventListener('keydown', handleEscape);
  });
}
 
 // Backup functionality
function openBackupSettings() {
  const modal = document.getElementById('backupModal');
  const frequency = localStorage.getItem(BACKUP_FREQUENCY_KEY) || 'none';
  const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
  const lastBackup = localStorage.getItem(LAST_BACKUP_KEY);
  
  document.getElementById('backupFrequency').value = frequency;
  document.getElementById('backupRetention').value = retention;
  
  if (lastBackup) {
    const date = new Date(parseInt(lastBackup));
    document.getElementById('lastBackupTime').textContent = date.toLocaleString();
  } else {
    document.getElementById('lastBackupTime').textContent = 'Never';
  }
  
  modal.className = 'modal show';
  closeMenu();
}

function closeBackupSettings() {
  document.getElementById('backupModal').className = 'modal';
}

function updateBackupFrequency() {
  const frequency = document.getElementById('backupFrequency').value;
  const retention = document.getElementById('backupRetention').value;
  
  localStorage.setItem(BACKUP_FREQUENCY_KEY, frequency);
  localStorage.setItem(BACKUP_RETENTION_KEY, retention);
  
  // Stop existing interval
  if (backupInterval) {
    clearInterval(backupInterval);
    backupInterval = null;
  }
  
  // Start new interval based on frequency
  if (frequency !== 'none') {
    startBackupSchedule(frequency);
  }
}

function startBackupSchedule(frequency) {
  const intervals = {
    'daily': 24 * 60 * 60 * 1000,      // 24 hours
    'weekly': 7 * 24 * 60 * 60 * 1000, // 7 days
    'monthly': 30 * 24 * 60 * 60 * 1000 // 30 days
  };
  
  const intervalMs = intervals[frequency];
  if (!intervalMs) return;
  
  // Check if backup is needed now
  const lastBackup = localStorage.getItem(LAST_BACKUP_KEY);
  const now = Date.now();
  
  if (!lastBackup || (now - parseInt(lastBackup)) >= intervalMs) {
    createAutomaticBackup();
  }
  
  // Set up recurring interval
  backupInterval = setInterval(() => {
    createAutomaticBackup();
  }, intervalMs);
}

function createAutomaticBackup() {
  try {
    const backups = getBackups();
    const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
    
    const backup = {
      timestamp: Date.now(),
      data: window.data || [],
      goals: window.goals || [],
      recentBooks: window.recentBooks || [],
      type: 'automatic'
    };
    
    backups.push(backup);
    
    // Apply retention policy
    if (retention !== 'all') {
      const maxBackups = parseInt(retention);
      if (backups.length > maxBackups) {
        // Keep only the most recent backups
        backups.sort((a, b) => b.timestamp - a.timestamp);
        backups.splice(maxBackups);
      }
    }
    
    localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
    localStorage.setItem(LAST_BACKUP_KEY, Date.now().toString());
    
    console.log('Automatic backup created');
  } catch (error) {
    console.error('Backup error:', error);
  }
}

async function createManualBackup() {
  try {
    const backups = getBackups();
    const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
    
    const backup = {
      timestamp: Date.now(),
      data: window.data || [],
      goals: window.goals || [],
      recentBooks: window.recentBooks || [],
      type: 'manual'
    };
    
    backups.push(backup);
    
    // Apply retention policy
    if (retention !== 'all') {
      const maxBackups = parseInt(retention);
      if (backups.length > maxBackups) {
        backups.sort((a, b) => b.timestamp - a.timestamp);
        backups.splice(maxBackups);
      }
    }
    
    localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
    localStorage.setItem(LAST_BACKUP_KEY, Date.now().toString());
    
    // Update display
    const date = new Date(backup.timestamp);
    document.getElementById('lastBackupTime').textContent = date.toLocaleString();
    
    await customAlert('Backup created successfully!', 'Backup Created');
  } catch (error) {
    console.error('Manual backup error:', error);
    await customAlert('Failed to create backup: ' + error.message, 'Backup Error');
  }
}

function getBackups() {
  try {
    const stored = localStorage.getItem(BACKUPS_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (error) {
    console.error('Error loading backups:', error);
    return [];
  }
}

function viewBackups() {
  const backups = getBackups();
  const container = document.getElementById('backupsList');
  
  if (backups.length === 0) {
    container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No backups available</div>';
  } else {
    // Sort by timestamp, newest first
    backups.sort((a, b) => b.timestamp - a.timestamp);
    
    container.innerHTML = '';
    backups.forEach((backup, index) => {
      const date = new Date(backup.timestamp);
      const backupDiv = document.createElement('div');
      backupDiv.className = 'entry-item';
      backupDiv.style.marginBottom = '8px';
      
      const entriesCount = backup.data ? backup.data.length : 0;
      const goalsCount = backup.goals ? backup.goals.length : 0;
      const type = backup.type === 'manual' ? 'üë§ Manual' : 'ü§ñ Automatic';
      
      backupDiv.innerHTML = `
        <div class="entry-info">
          <strong>${date.toLocaleString()}</strong><br>
          <span class="entry-detail">${type} ‚Ä¢ ${entriesCount} entries ‚Ä¢ ${goalsCount} goals</span>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn" onclick="restoreBackup(${index})" style="padding: 4px 12px; font-size: 12px;">Restore</button>
          <button class="btn" onclick="downloadBackup(${index})" style="padding: 4px 12px; font-size: 12px;">Download</button>
          <button class="delete-btn" onclick="deleteBackup(${index})">Delete</button>
        </div>
      `;
      
      container.appendChild(backupDiv);
    });
  }
  
  closeBackupSettings();
  document.getElementById('viewBackupsModal').className = 'modal show';
}

function closeViewBackups() {
  document.getElementById('viewBackupsModal').className = 'modal';
}

async function restoreBackup(index) {
  const backups = getBackups();
  if (index < 0 || index >= backups.length) {
    await customAlert('Backup not found.', 'Error');
    return;
  }
  
  const backup = backups[index];
  const date = new Date(backup.timestamp);
  
  const confirmed = await customConfirm(
    `Restore backup from ${date.toLocaleString()}?\n\nThis will replace your current data with the backup data.\n\nCurrent data will be lost unless you create a backup first.`,
    'Restore Backup'
  );
  
  if (!confirmed) return;
  
  try {
    window.data = backup.data || [];
    window.goals = backup.goals || [];
    window.recentBooks = backup.recentBooks || [];
    
    data = window.data;
    goals = window.goals;
    recentBooks = window.recentBooks;
    
    await saveToStorage();
    aggregateData();
    loadYear();
    renderGoals();
    
    if (window.saveCloudState) {
      await window.saveCloudState();
    }
    
    closeViewBackups();
    await customAlert('Backup restored successfully!', 'Restore Complete');
  } catch (error) {
    console.error('Restore error:', error);
    await customAlert('Failed to restore backup: ' + error.message, 'Restore Error');
  }
}

function downloadBackup(index) {
  const backups = getBackups();
  if (index < 0 || index >= backups.length) return;
  
  const backup = backups[index];
  const date = new Date(backup.timestamp);
  const dateStr = date.toISOString().split('T')[0];
  
  const exportData = {
    data: backup.data || [],
    goals: backup.goals || [],
    recentBooks: backup.recentBooks || [],
    backupDate: date.toISOString(),
    type: backup.type || 'manual'
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `reading-backup-${dateStr}-${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function deleteBackup(index) {
  const confirmed = await customConfirm(
    'Delete this backup?',
    'Delete Backup'
  );
  
  if (!confirmed) return;
  
  try {
    const backups = getBackups();
    backups.splice(index, 1);
    localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
    
    // Refresh the view
    viewBackups();
  } catch (error) {
    console.error('Delete backup error:', error);
    await customAlert('Failed to delete backup: ' + error.message, 'Delete Error');
  }
}

async function deleteAllBackups() {
  const backups = getBackups();
  if (backups.length === 0) {
    await customAlert('No backups to delete.', 'No Backups');
    return;
  }
  
  const confirmed = await customConfirm(
    `Delete all ${backups.length} backup(s)?\n\nThis action cannot be undone.`,
    'Delete All Backups'
  );
  
  if (!confirmed) return;
  
  try {
    localStorage.removeItem(BACKUPS_KEY);
    localStorage.removeItem(LAST_BACKUP_KEY);
    
    await customAlert('All backups have been deleted.', 'Backups Deleted');
    closeBackupSettings();
  } catch (error) {
    console.error('Delete all backups error:', error);
    await customAlert('Failed to delete backups: ' + error.message, 'Delete Error');
  }
}

// Initialize backup schedule on load
function initializeBackups() {
  const frequency = localStorage.getItem(BACKUP_FREQUENCY_KEY);
  if (frequency && frequency !== 'none') {
    startBackupSchedule(frequency);
  }
}
 </script>
<!-- Firebase integration: Auth (Google) + Firestore -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import { getAuth, setPersistence, browserLocalPersistence, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAmGPOSR03tCzi3cftfaP6JTBSk30JUgIw",
    authDomain: "timetracker-79479.firebaseapp.com",
    projectId: "timetracker-79479",
    storageBucket: "timetracker-79479.appspot.com",
    appId: "1:374798694344:web:77b1e15a27fc03ce76b2fd"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Listen for auth state changes to persist login across reloads
  // Listen for auth state changes to persist login across reloads
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      window.currentUser = {
        id: user.uid,
        name: user.displayName || 'User',
        email: user.email || '',
        avatar: user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName || 'User')}&background=random&size=128`
      };
      
      // Sync with local variable
      if (typeof currentUser !== 'undefined') {
        currentUser = window.currentUser;
      }
      
      localStorage.setItem('reading_heatmap_user', JSON.stringify(window.currentUser));
      
      // Update UI
      if (window.renderUserProfile) window.renderUserProfile();
      
      // Load user's data from cloud
      await loadCloudState(user.uid);
      
      // Sync all data with local variables
      if (typeof data !== 'undefined') data = window.data;
      if (typeof dailyData !== 'undefined') dailyData = window.dailyData;
      if (typeof goals !== 'undefined') goals = window.goals;
      if (typeof recentBooks !== 'undefined') recentBooks = window.recentBooks;
      
      if (window.aggregateData) window.aggregateData();
      if (window.loadYear) window.loadYear();
      if (window.renderGoals) window.renderGoals();
    } else {
      // User signed out - clear everything
      window.currentUser = null;
      window.data = [];
      window.dailyData = {};
      window.goals = [];
      window.recentBooks = [];
      
      // Sync with local variables
      if (typeof currentUser !== 'undefined') currentUser = null;
      if (typeof data !== 'undefined') data = [];
      if (typeof dailyData !== 'undefined') dailyData = {};
      if (typeof goals !== 'undefined') goals = [];
      if (typeof recentBooks !== 'undefined') recentBooks = [];
      
      localStorage.removeItem('reading_heatmap_user');
      
      if (window.initializeAuthButton) window.initializeAuthButton();
      if (window.aggregateData) window.aggregateData();
      if (window.loadYear) window.loadYear();
      if (window.renderGoals) window.renderGoals();
    }
  });

  async function firebaseSignIn() {
    try {
      const provider = new GoogleAuthProvider();
      provider.setCustomParameters({ prompt: 'select_account' });
      const result = await signInWithPopup(auth, provider);
      // Auth state change listener will handle the rest
    } catch (error) {
      console.error('Sign-in error:', error);
      await customAlert('Sign-in failed: ' + error.message, 'Sign-In Error');
    }
  }

  async function firebaseSignOut() {
    try {
      await signOut(auth);
      // Auth state change listener will handle the rest
      await customAlert('Successfully signed out', 'Signed Out');
    } catch (error) {
      console.error('Sign-out error:', error);
      await customAlert('Sign-out failed: ' + error.message, 'Sign-Out Error');
    }
  }

  async function loadCloudState(uid) {
    try {
      const ref = doc(db, 'users', uid, 'reading', 'heatmap');
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const cloud = snap.data();
        window.data = Array.isArray(cloud.data) ? cloud.data : [];
        window.goals = Array.isArray(cloud.goals) ? cloud.goals : [];
        window.recentBooks = Array.isArray(cloud.recentBooks) ? cloud.recentBooks : [];
        
        // Sync with local variables
        if (typeof data !== 'undefined') data = window.data;
        if (typeof goals !== 'undefined') goals = window.goals;
        if (typeof recentBooks !== 'undefined') recentBooks = window.recentBooks;
      } else {
        // First time user - initialize empty
        window.data = [];
        window.goals = [];
        window.recentBooks = [];
        
        // Sync with local variables
        if (typeof data !== 'undefined') data = [];
        if (typeof goals !== 'undefined') goals = [];
        if (typeof recentBooks !== 'undefined') recentBooks = [];
        
        await setDoc(ref, { 
          data: [], 
          goals: [], 
          recentBooks: [], 
          lastUpdated: new Date().toISOString() 
        });
      }
    } catch (error) {
      console.error('Error loading cloud state:', error);
      await customAlert('Failed to load your data from cloud. Please try again.', 'Load Error');
    }
  }

  async function saveCloudState() {
    if (!window.currentUser) return;
    try {
      const ref = doc(db, 'users', window.currentUser.id, 'reading', 'heatmap');
      await setDoc(ref, {
        data: window.data || [],
        goals: window.goals || [],
        recentBooks: window.recentBooks || [],
        lastUpdated: new Date().toISOString()
      }, { merge: true });
      
      // Also update leaderboard
      await updateCloudLeaderboard();
    } catch (error) {
      console.error('Error saving to cloud:', error);
    }
  }

  async function updateCloudLeaderboard() {
  if (!window.currentUser) return;
  
  let totalMinutes = 0;
  let totalCharacters = 0;
  Object.values(window.dailyData || {}).forEach(day => {
    totalMinutes += day.minutes || 0;
    totalCharacters += day.characters || 0;
  });
  
const totalHours = totalMinutes / 60;
const avgSpeed = totalHours > 0 ? Math.round(totalCharacters / totalHours) : 0;  
  const leaderboardEntry = {
    userId: window.currentUser.id,
    name: window.currentUser.name,
    avatar: window.currentUser.avatar,
    totalMinutes: totalMinutes,
    totalCharacters: totalCharacters,
    avgSpeed: avgSpeed,
    lastUpdated: new Date().toISOString()
  };
  
  try {
    const ref = doc(db, 'leaderboard', window.currentUser.id);
    await setDoc(ref, leaderboardEntry);
  } catch (error) {
    console.error('Failed to update leaderboard:', error);
  }
}
async function loadLeaderboardData() {
  const container = document.getElementById('leaderboardList');
  const metric = document.getElementById('leaderboardMetric')?.value || 'minutes';
  
  try {
    const leaderboardRef = collection(db, 'leaderboard');
    const snapshot = await getDocs(leaderboardRef);
    
    const leaderboardData = [];
    snapshot.forEach((docSnap) => {
      const data = docSnap.data();
      // Only include users with data
      if ((metric === 'minutes' && data.totalMinutes > 0) ||
          (metric === 'characters' && data.totalCharacters > 0) ||
          (metric === 'speed' && data.avgSpeed > 0)) {
        leaderboardData.push(data);
      }
    });
    
    if (leaderboardData.length === 0) {
      container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No leaderboard data yet. Be the first to log!</div>';
      return;
    }
    
    // Sort by selected metric
    if (metric === 'minutes') {
      leaderboardData.sort((a, b) => b.totalMinutes - a.totalMinutes);
    } else if (metric === 'characters') {
      leaderboardData.sort((a, b) => b.totalCharacters - a.totalCharacters);
    } else if (metric === 'speed') {
      leaderboardData.sort((a, b) => b.avgSpeed - a.avgSpeed);
    }
    
    // Find current user's position
    let userPosition = -1;
    if (window.currentUser) {
      userPosition = leaderboardData.findIndex(entry => entry.userId === window.currentUser.id);
    }
    
    // Check if we should show "Show More" button
    const showAll = container.dataset.showAll === 'true';
    const displayCount = showAll ? leaderboardData.length : 10;
    
    container.innerHTML = '';
    
    leaderboardData.slice(0, displayCount).forEach((entry, index) => {
      const rankDiv = document.createElement('div');
      rankDiv.className = 'leaderboard-entry';
      
      // Highlight current user
      const isCurrentUser = window.currentUser && entry.userId === window.currentUser.id;
      if (isCurrentUser) {
        rankDiv.style.background = 'var(--accent-color)';
        rankDiv.style.color = '#ffffff';
        rankDiv.style.fontWeight = '600';
      }
      
      const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
      
      let displayValue;
      if (metric === 'minutes') {
        displayValue = `${entry.totalMinutes.toLocaleString()} min`;
      } else if (metric === 'characters') {
        displayValue = `${entry.totalCharacters.toLocaleString()} chars`;
      } else if (metric === 'speed') {
        displayValue = `${entry.avgSpeed.toLocaleString()} char/hr`; 
    }
      
      rankDiv.innerHTML = `
        <div class="leaderboard-rank" style="${isCurrentUser ? 'color: #ffffff;' : ''}">${medal}</div>
        <div class="leaderboard-user">
          <img src="${entry.avatar || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22 fill=%22%23888%22/%3E%3C/svg%3E'}" class="user-avatar" alt="${entry.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22 fill=%22%23888%22/%3E%3C/svg%3E'" style="width: 32px; height: 32px; border-radius: 50%;">
          <span>${entry.name}${isCurrentUser ? ' (You)' : ''}</span>
        </div>
        <div class="leaderboard-value" style="${isCurrentUser ? 'color: #ffffff;' : ''}">${displayValue}</div>
      `;
      
      container.appendChild(rankDiv);
    });
    
    // Add "Show More" / "Show Less" button if there are more than 10 entries
    if (leaderboardData.length > 10) {
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'btn';
      toggleBtn.style.width = '100%';
      toggleBtn.style.marginTop = '12px';
      toggleBtn.textContent = showAll ? 'Show Less' : `Show More (${leaderboardData.length - 10} more)`;
      toggleBtn.onclick = () => {
        container.dataset.showAll = showAll ? 'false' : 'true';
        loadLeaderboardData();
      };
      container.appendChild(toggleBtn);
    }
    
    // Show user's position if they're not in top 10 but exists in leaderboard
    if (!showAll && userPosition >= 10 && window.currentUser) {
      const userEntry = leaderboardData[userPosition];
      const separatorDiv = document.createElement('div');
      separatorDiv.style.margin = '16px 0 8px 0';
      separatorDiv.style.padding = '8px 0';
      separatorDiv.style.borderTop = '2px dashed var(--border-color)';
      separatorDiv.style.color = 'var(--text-secondary)';
      separatorDiv.style.textAlign = 'center';
      separatorDiv.style.fontSize = '12px';
      separatorDiv.textContent = 'Your Position';
      container.appendChild(separatorDiv);
      
      const userRankDiv = document.createElement('div');
      userRankDiv.className = 'leaderboard-entry';
      userRankDiv.style.background = 'var(--accent-color)';
      userRankDiv.style.color = '#ffffff';
      userRankDiv.style.fontWeight = '600';
      
      let displayValue;
      if (metric === 'minutes') {
        displayValue = `${userEntry.totalMinutes.toLocaleString()} min`;
      } else if (metric === 'characters') {
        displayValue = `${userEntry.totalCharacters.toLocaleString()} chars`;
      } else if (metric === 'speed') {
        displayValue = `${userEntry.avgSpeed.toLocaleString()} ch/m`;
      }
      
      userRankDiv.innerHTML = `
        <div class="leaderboard-rank" style="color: #ffffff;">#${userPosition + 1}</div>
        <div class="leaderboard-user">
          <img src="${userEntry.avatar}" class="user-avatar" alt="${userEntry.name}" style="width: 32px; height: 32px; border-radius: 50%;">
          <span>${userEntry.name} (You)</span>
        </div>
        <div class="leaderboard-value" style="color: #ffffff;">${displayValue}</div>
      `;
      
      container.appendChild(userRankDiv);
    }
    
  } catch (error) {
    container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Error: ' + error.message + '</div>';
    console.error('Leaderboard error details:', error);
  }
}

  // Make functions globally available
  window.firebaseSignIn = firebaseSignIn;
  window.firebaseSignOut = firebaseSignOut;
  window.saveCloudState = saveCloudState;
  window.loadLeaderboardData = loadLeaderboardData;
  // Override promptSignIn to use Firebase
  window.promptSignIn = firebaseSignIn;

 // ============================================
// ttsu Google Drive Auto-Sync Integration
// ============================================

const GDRIVE_CONFIG = {
  clientId: '510422773254-e8a8reeuce9jtn7dgjqq8c7kmeopikdr.apps.googleusercontent.com',
  apiKey: 'AIzaSyDOHQjTJYPXMQ-6p45ReF6dBRvmxUZ0P_k',
  scopes: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.metadata.readonly'
};

let googleAccessToken = null;
let tokenClient = null;

const TTSU_SYNC_ENABLED_KEY = 'ttsu_sync_enabled';
const TTSU_LAST_SYNC_KEY = 'ttsu_last_sync';
const TTSU_FOLDER_ID_KEY = 'ttsu_folder_id';
const TTSU_TOKEN_KEY = 'ttsu_access_token';
const TTSU_TOKEN_EXPIRY_KEY = 'ttsu_token_expiry';

let ttsuSyncInterval = null;

// Initialize GIS only (no GAPI needed)
function initGIS() {
  if (typeof google === 'undefined' || !google.accounts) {
    console.log('Google Identity Services not loaded yet');
    return false;
  }
  
  if (!tokenClient) {
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: GDRIVE_CONFIG.clientId,
      scope: GDRIVE_CONFIG.scopes,
      callback: '', // set during auth
    });
    console.log('GIS initialized');
  }
  return true;
}

// Direct REST API calls (no gapi.client needed)
async function driveApiCall(endpoint, accessToken) {
  const response = await fetch(`https://www.googleapis.com/drive/v3/${endpoint}`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Accept': 'application/json'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Drive API error: ${response.status} ${response.statusText}`);
  }
  
  return await response.json();
}

async function driveDownloadFile(fileId, accessToken) {
  const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });
  
  if (!response.ok) {
    throw new Error(`Download error: ${response.status}`);
  }
  
  return await response.text();
}

async function setupTtsuSync() {
  try {
    let attempts = 0;
    while (!initGIS() && attempts < 20) {
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }
    if (!tokenClient) throw new Error('Google Identity Services not loaded. Please refresh the page.');

    // Explicit consent only during setup
    const ok = await ensureDriveToken({ allowPrompt: true });
    if (!ok) throw new Error('Authorization failed. Please try again.');

    const folderId = await findTtsuFolder();
    if (!folderId) {
      await customAlert('Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!', 'Folder Not Found');
      return;
    }

    localStorage.setItem(TTSU_FOLDER_ID_KEY, folderId);
    localStorage.setItem(TTSU_SYNC_ENABLED_KEY, 'true');

    await syncFromTtsuGDrive();
    startAutoSync();

    const statusEl = document.getElementById('ttsuSyncStatusText');
    if (statusEl) {
      const s = checkTtsuSyncStatus();
      statusEl.textContent = s;
      statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
    }

    await customAlert('‚úÖ ttsu sync enabled! It will auto-sync every 5 minutes.', 'Sync Enabled');
    closeTtsuSyncModal();
  } catch (error) {
    console.error('Setup error:', error);
    await customAlert('Failed to setup ttsu sync:\n\n' + (error.message || JSON.stringify(error)), 'Setup Error');
  }
}


async function findTtsuFolder() {
  try {
    console.log('Searching for ttu-reader-data folder...');
    
    // Simple search without complex query
    const data = await driveApiCall(`files?q=name='ttu-reader-data'&fields=files(id,name)&spaces=drive`, googleAccessToken);
    
    console.log('Search results:', data);
    
    if (data.files && data.files.length > 0) {
      console.log('Found folder:', data.files[0].name, 'ID:', data.files[0].id);
      return data.files[0].id;
    }
    
    // If not found, list all folders to debug
    console.log('Not found. Listing all folders...');
    const allFolders = await driveApiCall(`files?q=mimeType='application/vnd.google-apps.folder'&fields=files(id,name)&spaces=drive&pageSize=100`, googleAccessToken);
    
    console.log('All folders:', allFolders.files);
    
    return null;
  } catch (error) {
    console.error('Error finding ttsu folder:', error);
    return null;
  }
}

async function syncFromTtsuGDrive() {
  try {
    const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    if (!folderId) {
      throw new Error('ttsu folder not configured. Please run setup first.');
    }
    
    if (!googleAccessToken) {
      throw new Error('Not authenticated. Please run setup first.');
    }
    
    console.log('Fetching book folders from ttu-reader-data...');
    
    // First, get all book folders inside ttu-reader-data
  const bookFoldersQuery = encodeURIComponent(`'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
  const bookFoldersData = await driveApiCall(`files?q=${bookFoldersQuery}&spaces=drive&fields=files(id,name)&pageSize=100`, googleAccessToken);

    const bookFolders = bookFoldersData.files || [];
    console.log(`Found ${bookFolders.length} book folders`);
    
    if (bookFolders.length === 0) {
      console.log('No book folders found');
      return 0;
    }
    
    let totalImported = 0;
    const bookTitles = new Set();
    
    // For each book folder, get the statistics file
    for (const bookFolder of bookFolders) {
      try {
        console.log(`Checking folder: ${bookFolder.name}`);
        
        // Find statistics JSON file in this book folder
        const statsQuery = encodeURIComponent(`'${bookFolder.id}' in parents and name contains 'statistics' and mimeType='application/json'`);
        const statsData = await driveApiCall(`files?q=${statsQuery}&spaces=drive&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc`, googleAccessToken);
        
        const files = statsData.files || [];
        
        if (files.length === 0) {
          console.log(`No statistics file in ${bookFolder.name}`);
          continue;
        }
        
        // Process the statistics file (usually just one per book)
        const file = files[0];
        console.log(`Processing ${file.name}...`);
        
        // Download file content
        const fileContent = await driveDownloadFile(file.id, googleAccessToken);
        const ttsuData = JSON.parse(fileContent);
        
        if (!Array.isArray(ttsuData)) continue;
        
        // Transform and import data
        ttsuData.forEach(session => {
          if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
            return;
          }
          
          const date = session.dateKey;
          const minutes = Math.round(session.readingTime / 60);
          const characters = session.charactersRead || 0;
          
          if (minutes === 0 && characters === 0) return;
          
          // Check if exists
          const exists = window.data.some(entry => 
            entry.date === date && 
            entry.title === session.title &&
            Math.abs(entry.minutes - minutes) < 2 &&
            Math.abs(entry.characters - characters) < 100
          );
          
          if (!exists) {
            window.data.push({
              date: date,
              minutes: minutes,
              characters: characters,
              title: session.title || bookFolder.name || 'Reading'
            });
            totalImported++;
            bookTitles.add(session.title || bookFolder.name);
          }
        });
        
      } catch (fileError) {
        console.error('Error processing folder:', bookFolder.name, fileError);
      }
    }
    
if (totalImported > 0) {
  // Ask user before importing
  const bookList = Array.from(bookTitles).join(', ');
  const confirmed = confirm(
    `Found ${totalImported} new reading session(s) from ttsu.\n\n` +
    `Books: ${bookList}\n\n` +
    `Import these sessions?`
  );
  
  if (!confirmed) {
    console.log('User cancelled ttsu import');
    return 0;
  }
  
  // Update recent books
  bookTitles.forEach(title => {
        if (title && !window.recentBooks.includes(title)) {
          window.recentBooks.unshift(title);
        }
      });
      window.recentBooks = window.recentBooks.slice(0, 10);
      recentBooks = window.recentBooks;
      
      data = window.data;
      
      await saveToStorage();
      aggregateData();
      loadYear();
      renderGoals();
      
      if (window.saveCloudState) {
        await window.saveCloudState();
      }
      
      console.log(`‚úÖ Synced ${totalImported} new sessions from ttsu`);
    }
    
    localStorage.setItem(TTSU_LAST_SYNC_KEY, new Date().toISOString());
    
    return totalImported;
    
  } catch (error) {
    console.error('Sync error:', error);
    throw error;
  }
}

async function batchLoadAllTtsu() {
  // First confirmation
  const firstConfirm = await customConfirm(
    '‚ö†Ô∏è BATCH LOAD ALL FROM TTSU ‚ö†Ô∏è\n\nThis will:\n1. Load ALL reading data from ttsu Google Drive\n2. OVERWRITE your existing data\n3. This action CANNOT be undone\n\nAre you sure you want to continue?',
    'Batch Load Warning'
  );
  
  if (!firstConfirm) return;
  
  // Second confirmation to prevent accidents
  const secondConfirm = await customConfirm(
    'FINAL CONFIRMATION\n\nYour current reading data will be PERMANENTLY REPLACED with all data from ttsu.\n\nClick OK to proceed or Cancel to abort.',
    'Final Confirmation'
  );
  
  if (!secondConfirm) return;
  
  try {
    const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    if (!folderId) {
      // Try to find folder if not configured
      const hasToken = await ensureDriveToken({ allowPrompt: true });
      if (!hasToken) {
        throw new Error('Authorization failed. Please try again.');
      }
      
      const foundFolderId = await findTtsuFolder();
      if (!foundFolderId) {
        await customAlert(
          'Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!',
          'Folder Not Found'
        );
        return;
      }
      
      localStorage.setItem(TTSU_FOLDER_ID_KEY, foundFolderId);
    } else {
      // Ensure we have a valid token
      const hasToken = await ensureDriveToken({ allowPrompt: false });
      if (!hasToken) {
        await customAlert(
          'Google Drive authorization has expired. Please press "Setup ttsu Auto-Sync" once to refresh authorization.',
          'Authorization Expired'
        );
        return;
      }
    }
    
    const statusEl = document.getElementById('ttsuSyncStatusText');
    if (statusEl) {
      statusEl.textContent = 'Loading all data from ttsu...';
      statusEl.style.color = 'var(--accent-color)';
    }
    
    console.log('Starting batch load of all ttsu data...');
    
    const fId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    // Get all book folders inside ttu-reader-data
    const bookFoldersQuery = encodeURIComponent(`'${fId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
    const bookFoldersData = await driveApiCall(`files?q=${bookFoldersQuery}&spaces=drive&fields=files(id,name)&pageSize=100`, googleAccessToken);

    const bookFolders = bookFoldersData.files || [];
    console.log(`Found ${bookFolders.length} book folders`);
    
    if (bookFolders.length === 0) {
      await customAlert('No book folders found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    // Clear existing data
    window.data = [];
    data = [];
    
    let totalImported = 0;
    const bookTitles = new Set();
    
    // For each book folder, get the statistics file
    for (const bookFolder of bookFolders) {
      try {
        console.log(`Processing folder: ${bookFolder.name}`);
        
        // Find statistics JSON file in this book folder
        const statsQuery = encodeURIComponent(`'${bookFolder.id}' in parents and name contains 'statistics' and mimeType='application/json'`);
        const statsData = await driveApiCall(`files?q=${statsQuery}&spaces=drive&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc`, googleAccessToken);
        
        const files = statsData.files || [];
        
        if (files.length === 0) {
          console.log(`No statistics file in ${bookFolder.name}`);
          continue;
        }
        
        // Process the statistics file
        const file = files[0];
        console.log(`Processing ${file.name}...`);
        
        // Download file content
        const fileContent = await driveDownloadFile(file.id, googleAccessToken);
        const ttsuData = JSON.parse(fileContent);
        
        if (!Array.isArray(ttsuData)) continue;
        
        // Transform and import ALL data (no duplicate checking since we're overwriting)
        ttsuData.forEach(session => {
          if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
            return;
          }
          
          const date = session.dateKey;
          const minutes = Math.round(session.readingTime / 60);
          const characters = session.charactersRead || 0;
          
          if (minutes === 0 && characters === 0) return;
          
          window.data.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || bookFolder.name || 'Reading'
          });
          totalImported++;
          bookTitles.add(session.title || bookFolder.name);
        });
        
      } catch (fileError) {
        console.error('Error processing folder:', bookFolder.name, fileError);
      }
    }
    
    if (totalImported === 0) {
      await customAlert('No reading data found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    // Update recent books
    bookTitles.forEach(title => {
      if (title && !window.recentBooks.includes(title)) {
        window.recentBooks.unshift(title);
      }
    });
    window.recentBooks = window.recentBooks.slice(0, 10);
    recentBooks = window.recentBooks;
    
    data = window.data;
    
    await saveToStorage();
    aggregateData();
    loadYear();
    renderGoals();
    
    if (window.saveCloudState) {
      await window.saveCloudState();
    }
    
    localStorage.setItem(TTSU_LAST_SYNC_KEY, new Date().toISOString());
    
    console.log(`‚úÖ Batch loaded ${totalImported} sessions from ttsu`);
    
    const bookList = Array.from(bookTitles).slice(0, 10).join(', ');
    const moreBooks = bookTitles.size > 10 ? `\n...and ${bookTitles.size - 10} more books` : '';
    
    await customAlert(
      `‚úÖ Batch Load Complete!\n\nImported: ${totalImported} reading sessions\nBooks: ${bookList}${moreBooks}\n\nYour data has been overwritten with ttsu data.`,
      'Success'
    );
    
    if (statusEl) {
      const s = checkTtsuSyncStatus();
      statusEl.textContent = s;
      statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
    }
    
    closeTtsuSyncModal();
    
  } catch (error) {
    console.error('Batch load error:', error);
    await customAlert(
      'Failed to batch load from ttsu:\n\n' + (error.message || error),
      'Error'
    );
    
    const statusEl = document.getElementById('ttsuSyncStatusText');
    if (statusEl) {
      const s = checkTtsuSyncStatus();
      statusEl.textContent = s;
      statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
    }
  }
}

function startAutoSync() {
  if (ttsuSyncInterval) {
    clearInterval(ttsuSyncInterval);
  }
  
  ttsuSyncInterval = setInterval(async () => {
    try {
      const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
      if (enabled) {
        console.log('Auto-syncing from ttsu...');
        await syncFromTtsuGDrive();
      }
    } catch (error) {
      console.error('Auto-sync error:', error);
    }
  }, 5 * 60 * 1000);
}

function stopAutoSync() {
  if (ttsuSyncInterval) {
    clearInterval(ttsuSyncInterval);
    ttsuSyncInterval = null;
  }
  localStorage.setItem(TTSU_SYNC_ENABLED_KEY, 'false');
}

async function manualSyncTtsu() {
  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);

  if (!enabled || !folderId) {
    await customAlert('ttsu sync is not enabled.\n\nPlease run "Setup ttsu Auto-Sync" once to configure.', 'Sync Not Enabled');
    return;
  }

  // Never prompt here; try silent token only
  const hasToken = await ensureDriveToken({ allowPrompt: false });
  if (!hasToken) {
    // Do not show Google consent; just inform and return gracefully
    await customAlert('Google Drive authorization has expired. Please press "Setup ttsu Auto-Sync" once to refresh authorization. No changes made.', 'Authorization Expired');
    return;
  }

  try {
    const count = await syncFromTtsuGDrive();
    const lastSync = localStorage.getItem(TTSU_LAST_SYNC_KEY);
    const lastSyncStr = lastSync ? new Date(lastSync).toLocaleString() : 'Never';

    await customAlert(`‚úÖ Sync complete!\n\nNew sessions imported: ${count || 0}\nLast sync: ${lastSyncStr}`, 'Sync Complete');

    // Update status UI
    const statusEl = document.getElementById('ttsuSyncStatusText');
    if (statusEl) {
      const s = checkTtsuSyncStatus();
      statusEl.textContent = s;
      statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
    }
  } catch (error) {
    await customAlert('Sync failed:\n\n' + (error.message || error), 'Sync Error');
  }
}

async function disableTtsuSync() {
  const confirmed = await customConfirm(
    'Disable automatic ttsu sync from Google Drive?',
    'Disable Sync'
  );
  
  if (!confirmed) return;
  
  stopAutoSync();
  localStorage.removeItem(TTSU_SYNC_ENABLED_KEY);
  localStorage.removeItem(TTSU_FOLDER_ID_KEY);
  localStorage.removeItem(TTSU_TOKEN_KEY);
  localStorage.removeItem(TTSU_TOKEN_EXPIRY_KEY);
  googleAccessToken = null;
  await customAlert('ttsu sync disabled.', 'Sync Disabled');
  
  const statusEl = document.getElementById('ttsuSyncStatusText');
  if (statusEl) {
    const s = checkTtsuSyncStatus();
    statusEl.textContent = s;
    statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
  }
}

function checkTtsuSyncStatus() {
  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
  const lastSync = localStorage.getItem(TTSU_LAST_SYNC_KEY);

  // Not configured unless both enabled and a folderId exist
  if (!enabled || !folderId) {
    return 'Not configured';
  }

  // Configured ‚Üí Success (append recency if available)
  if (!lastSync) {
    return 'Success (not synced yet)';
  }

  const lastSyncDate = new Date(lastSync);
  const now = new Date();
  const diffMinutes = Math.floor((now - lastSyncDate) / 1000 / 60);

  if (diffMinutes < 1) {
    return 'Success (just synced)';
  } else if (diffMinutes < 60) {
    return `Success (last synced ${diffMinutes} min ago)`;
  } else {
    return `Success (last synced ${Math.floor(diffMinutes / 60)}h ago)`;
  }
}
// Helper: try to ensure we have a Google Drive access token
// allowPrompt=false prevents any consent UI from appearing
async function ensureDriveToken(options = { allowPrompt: false }) {
  // Check if we have a stored valid token
  const storedToken = localStorage.getItem(TTSU_TOKEN_KEY);
  const storedExpiry = localStorage.getItem(TTSU_TOKEN_EXPIRY_KEY);
  
  if (storedToken && storedExpiry) {
    const expiryTime = parseInt(storedExpiry);
    const now = Date.now();
    
    // If token is still valid (with 5 min buffer), use it
    if (expiryTime > now + (5 * 60 * 1000)) {
      googleAccessToken = storedToken;
      console.log('Using stored valid token');
      return true;
    }
  }
  
  // Token expired or doesn't exist - try to refresh silently
  try {
    await new Promise((resolve, reject) => {
      tokenClient.callback = (resp) => {
        if (resp && !resp.error && resp.access_token) {
          googleAccessToken = resp.access_token;
          
          // Store token with expiry (default 3600 seconds = 1 hour)
          const expiresIn = resp.expires_in || 3600;
          const expiryTime = Date.now() + (expiresIn * 1000);
          
          localStorage.setItem(TTSU_TOKEN_KEY, resp.access_token);
          localStorage.setItem(TTSU_TOKEN_EXPIRY_KEY, expiryTime.toString());
          
          console.log('Token refreshed and stored');
          resolve();
        } else {
          reject(resp?.error || new Error('silent_token_failed'));
        }
      };
      tokenClient.requestAccessToken({ prompt: '' });
    });
    return true;
  } catch (silentErr) {
    console.log('Silent token refresh failed:', silentErr);
    
    if (!options.allowPrompt) {
      // Clear invalid stored tokens
      localStorage.removeItem(TTSU_TOKEN_KEY);
      localStorage.removeItem(TTSU_TOKEN_EXPIRY_KEY);
      return false;
    }

    // One-time interactive consent during setup
    try {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp && !resp.error && resp.access_token) {
            googleAccessToken = resp.access_token;
            
            // Store token with expiry
            const expiresIn = resp.expires_in || 3600;
            const expiryTime = Date.now() + (expiresIn * 1000);
            
            localStorage.setItem(TTSU_TOKEN_KEY, resp.access_token);
            localStorage.setItem(TTSU_TOKEN_EXPIRY_KEY, expiryTime.toString());
            
            console.log('Token obtained via consent and stored');
            resolve();
          } else {
            reject(resp?.error || new Error('prompt_token_failed'));
          }
        };
        tokenClient.requestAccessToken({ prompt: 'consent' });
      });
      return true;
    } catch (promptErr) {
      localStorage.removeItem(TTSU_TOKEN_KEY);
      localStorage.removeItem(TTSU_TOKEN_EXPIRY_KEY);
      return false;
    }
  }
}

// Initialize on load: auto-start if previously configured (no consent prompts)
setTimeout(async () => {
  initGIS();

  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);

  if (enabled && folderId) {
    await ensureDriveToken({ allowPrompt: false }); // try silent token; ok if it fails
    startAutoSync();

    const statusEl = document.getElementById('ttsuSyncStatusText');
    if (statusEl) {
      const s = checkTtsuSyncStatus();
      statusEl.textContent = s;
      statusEl.style.color = s.toLowerCase().startsWith('success') ? 'var(--accent-color)' : 'var(--text-secondary)';
    }

    console.log('ttsu auto-sync initialized on load');
  }
}, 1000);

window.setupTtsuSync = setupTtsuSync;
window.syncFromTtsuGDrive = syncFromTtsuGDrive;
window.manualSyncTtsu = manualSyncTtsu;
window.batchLoadAllTtsu = batchLoadAllTtsu;
window.disableTtsuSync = disableTtsuSync;
window.checkTtsuSyncStatus = checkTtsuSyncStatus;

</script>
<!-- Spacer to push footer far below main UI -->
<div style="height: 18vh;"></div>

<footer style="padding: 6px 0; text-align: center; font-size: 10px; color: var(--text-secondary);">
  <p style="margin: 0;">
    <a href="/privacy.html" style="color: var(--text-secondary); text-decoration: none;">Privacy Policy</a>
    &nbsp;‚Ä¢&nbsp;
    <a href="/terms.html" style="color: var(--text-secondary); text-decoration: none;">Terms</a>
  </p>
</footer>

</body>
</html>