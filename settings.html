<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Settings - Ë™≠Êõ∏ track</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23ffffff'/%3E%3Cpath d='M25 20 L25 80 L50 75 L75 80 L75 20 L50 25 Z' fill='%23000000'/%3E%3Cline x1='50' y1='25' x2='50' y2='75' stroke='%23ffffff' stroke-width='2'/%3E%3Cline x1='32' y1='35' x2='45' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='43' x2='45' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='51' x2='45' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='59' x2='45' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='35' x2='68' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='43' x2='68' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='51' x2='68' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='59' x2='68' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Klee+One:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border-color: #30363d;
      --text-primary: #c9d1d9;
      --text-secondary: #8b949e;
      --accent-color: #238636;
      --accent-hover: #2ea043;
      --danger-color: #da3633;
      --danger-hover: #f85149;
    }
    
    body.theme-nord {
      --bg-primary: #2e3440;
      --bg-secondary: #3b4252;
      --bg-tertiary: #434c5e;
      --border-color: #4c566a;
      --text-primary: #eceff4;
      --text-secondary: #d8dee9;
      --accent-color: #88c0d0;
      --accent-hover: #8fbcbb;
      --danger-color: #bf616a;
      --danger-hover: #d08770;
    }

    body.theme-tokyo {
      --bg-primary: #1a1b26;
      --bg-secondary: #16161e;
      --bg-tertiary: #24283b;
      --border-color: #414868;
      --text-primary: #a9b1d6;
      --text-secondary: #565f89;
      --accent-color: #7aa2f7;
      --accent-hover: #7dcfff;
      --danger-color: #f7768e;
      --danger-hover: #ff9e64;
    }

    body.theme-dracula {
      --bg-primary: #282a36;
      --bg-secondary: #21222c;
      --bg-tertiary: #343746;
      --border-color: #44475a;
      --text-primary: #f8f8f2;
      --text-secondary: #6272a4;
      --accent-color: #ff5555;
      --accent-hover: #ff6e6e;
      --danger-color: #ff5555;
      --danger-hover: #ff6e6e;
    }

    body.theme-everforest {
      --bg-primary: #fdf6e3;
      --bg-secondary: #f4f0d9;
      --bg-tertiary: #efebd4;
      --border-color: #e0dcc7;
      --text-primary: #5c6a72;
      --text-secondary: #939f91;
      --accent-color: #8da101;
      --accent-hover: #a7b901;
      --danger-color: #f85552;
      --danger-hover: #e66868;
    }

    body.theme-onedark {
      --bg-primary: #282c34;
      --bg-secondary: #21252b;
      --bg-tertiary: #2c313c;
      --border-color: #3e4451;
      --text-primary: #abb2bf;
      --text-secondary: #5c6370;
      --accent-color: #98c379;
      --accent-hover: #b5cea8;
      --danger-color: #e06c75;
      --danger-hover: #be5046;
    }

    body.theme-nord-light {
      --bg-primary: #eceff4;
      --bg-secondary: #e5e9f0;
      --bg-tertiary: #d8dee9;
      --border-color: #c2c9d6;
      --text-primary: #2e3440;
      --text-secondary: #4c566a;
      --accent-color: #5e81ac;
      --accent-hover: #81a1c1;
      --danger-color: #bf616a;
      --danger-hover: #d08770;
    }

    body.theme-phoenix {
      --bg-primary: #170f1e;
      --bg-secondary: #1c1521;
      --bg-tertiary: #2b2032;
      --border-color: #3d2f47;
      --text-primary: #f5c2e7;
      --text-secondary: #988ba2;
      --accent-color: #cba6f7;
      --accent-hover: #d4b4f8;
      --danger-color: #f38ba8;
      --danger-hover: #f5a7bc;
    }

    body.theme-ereader {
      --bg-primary: #ffffff;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #e8e8e8;
      --border-color: #d0d0d0;
      --text-primary: #000000;
      --text-secondary: #666666;
      --accent-color: #333333;
      --accent-hover: #000000;
      --danger-color: #555555;
      --danger-hover: #333333;
    }
    
    body {
      font-family: "Klee One", cursive;
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 40px 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }
    
    h1 {
      font-size: 24px;
      font-weight: 700;
      color: #ffffff;
    }
    
    body.theme-everforest h1,
    body.theme-nord-light h1,
    body.theme-ereader h1 {
      color: var(--text-primary);
    }
    
    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-block;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .btn:hover {
      background: var(--border-color);
      border-color: var(--text-secondary);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    
    .settings-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }
    
    .settings-section h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: var(--text-primary);
    }
    
    .settings-section p {
      color: var(--text-secondary);
      font-size: 13px;
      margin-bottom: 16px;
      line-height: 1.6;
    }
    
    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-color);
    }
    
    .setting-item:last-child {
      border-bottom: none;
    }
    
    .setting-label {
      flex: 1;
    }
    
    .setting-label h3 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .setting-label p {
      font-size: 12px;
      color: var(--text-secondary);
      margin: 0;
    }
    
    .form-input, select {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }
    
    .form-input:focus, select:focus {
      outline: none;
      border-color: var(--accent-color);
    }
    
    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .confirm-btn {
      background: var(--border-color);
      border: 1px solid var(--text-secondary);
      color: var(--text-primary);
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    
    .confirm-btn:hover {
      background: var(--text-secondary);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
      transform: translateY(-1px);
    }
    
    .danger-btn {
      background: var(--danger-color);
      border: 1px solid var(--danger-color);
      color: #ffffff;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .danger-btn:hover {
      background: var(--danger-hover);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öôÔ∏è Settings</h1>
      <a href="index.html" class="btn">‚Üê Back to Heatmap</a>
    </header>
    
    <!-- Statistics Visibility -->
    <div class="settings-section">
      <h2>üìä Statistics Display</h2>
      <p>Choose which statistics to show on the main heatmap panel.</p>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showLongestStreak" onchange="toggleStat('longestStreak')" checked>
          <span style="margin-left: 8px;">Longest streak</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showCurrentStreak" onchange="toggleStat('currentStreak')" checked>
          <span style="margin-left: 8px;">Current streak</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showAverage" onchange="toggleStat('average')" checked>
          <span style="margin-left: 8px;">Average</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showAvgSpeed" onchange="toggleStat('avgSpeed')" checked>
          <span style="margin-left: 8px;">Average speed</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showTotal" onchange="toggleStat('total')" checked>
          <span style="margin-left: 8px;">Total</span>
        </label>
      </div>
    </div>
    
    <!-- Backup Settings -->
    <div class="settings-section">
      <h2>üíæ Automatic Backups</h2>
      <p>Automatically save backup copies of your reading data to protect against data loss.</p>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Backup Frequency</h3>
          <p>How often to create automatic backups</p>
        </div>
        <select id="backupFrequency" onchange="updateBackupFrequency()">
          <option value="none">Disabled</option>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Keep Last</h3>
          <p>Number of backups to keep</p>
        </div>
        <select id="backupRetention" onchange="updateBackupRetention()">
          <option value="3">3 backups</option>
          <option value="5">5 backups</option>
          <option value="10">10 backups</option>
          <option value="20">20 backups</option>
          <option value="all">All backups</option>
        </select>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Last Backup</h3>
          <p id="lastBackupTime">Never</p>
        </div>
        <div class="action-buttons">
          <button class="confirm-btn" onclick="createManualBackup()">Backup Now</button>
          <button class="btn" onclick="viewBackups()">View Backups</button>
        </div>
      </div>
    </div>
    
<!-- ttsu Sync Settings -->
<div class="settings-section">
  <h2>üîÑ ttsu Google Drive Sync</h2>
  <p>Automatically sync your reading data from the ttsu app via Google Drive.</p>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Sync Status</h3>
      <p id="ttsuSyncStatusText">Not configured</p>
    </div>
    <div class="action-buttons">
      <button class="confirm-btn" onclick="setupTtsuSync()">Setup Sync</button>
      <button class="btn" onclick="manualSyncTtsu()">Sync Now</button>
    </div>
  </div>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Batch Load</h3>
      <p>Load all ttsu data (overwrites existing data)</p>
    </div>
    <button class="btn" onclick="batchLoadAllTtsu()"">üì• Batch Load All</button>
  </div>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Disable Sync</h3>
      <p>Stop automatic syncing from ttsu</p>
    </div>
    <button class="danger-btn" onclick="disableTtsuSync()">Disable</button>
  </div>
</div>
    
    <!-- Data Management -->
    <div class="settings-section">
      <h2>üìÇ Data Management</h2>
      <p>Import, export, and manage your reading data.</p>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Export Data</h3>
          <p>Download your data as JSON or export to Toggl format</p>
        </div>
        <div class="action-buttons">
          <button class="btn" onclick="downloadData()">üíæ Download JSON</button>
          <button class="btn" onclick="exportToToggl()">‚è±Ô∏è Export to Toggl</button>
        </div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Import Data</h3>
          <p>Load data from JSON file or ttsu export</p>
        </div>
        <div class="action-buttons">
          <button class="btn" onclick="document.getElementById('fileInput').click()">üìÇ Load JSON</button>
          <button class="btn" onclick="document.getElementById('ttsuInput').click()">üìö Import ttsu</button>
        </div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Wipe All Data</h3>
          <p style="color: var(--danger-color);">‚ö†Ô∏è Permanently delete all reading data</p>
        </div>
        <button class="danger-btn" onclick="wipeAllData()">üóëÔ∏è Wipe All Data</button>
      </div>
    </div>
  </div>
  
  <input type="file" id="fileInput" style="display: none;" accept=".json">
  <input type="file" id="ttsuInput" style="display: none;" accept=".json">
  
  <script>

  // Load theme
  const THEME_KEY = 'reading_heatmap_theme';
  const STORAGE_KEY = 'reading_heatmap_data';
  const GOALS_KEY = 'reading_heatmap_goals';
  const BOOKS_KEY = 'reading_heatmap_books';
  const USER_KEY = 'reading_heatmap_user';
  const BACKUPS_KEY = 'reading_heatmap_backups';
  
  const theme = localStorage.getItem(THEME_KEY) || 'default';
  document.body.className = theme === 'default' ? '' : `theme-${theme}`;
  
  // Helper to get current data
  function getCurrentData() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getCurrentGoals() {
    try {
      const stored = localStorage.getItem(GOALS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getCurrentBooks() {
    try {
      const stored = localStorage.getItem(BOOKS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getBackups() {
    try {
      const stored = localStorage.getItem(BACKUPS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Error loading backups:', error);
      return [];
    }
  }
    
    // Load stat visibility settings
    function loadStatVisibility() {
      const stats = ['longestStreak', 'currentStreak', 'average', 'avgSpeed', 'total'];
      stats.forEach(stat => {
        const saved = localStorage.getItem(`show_${stat}`);
        if (saved !== null) {
          const checkbox = document.getElementById(`show${stat.charAt(0).toUpperCase() + stat.slice(1)}`);
          if (checkbox) {
            checkbox.checked = saved === 'true';
          }
        }
      });
    }
    
    function toggleStat(statName) {
      const checkbox = document.getElementById(`show${statName.charAt(0).toUpperCase() + statName.slice(1)}`);
      localStorage.setItem(`show_${statName}`, checkbox.checked);
    }
    
    // Load backup settings
    const BACKUP_FREQUENCY_KEY = 'reading_heatmap_backup_frequency';
const BACKUP_RETENTION_KEY = 'reading_heatmap_backup_retention';
const LAST_BACKUP_KEY = 'reading_heatmap_last_backup';

function loadBackupSettings() {
  const frequency = localStorage.getItem(BACKUP_FREQUENCY_KEY) || 'none';
  const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
  const lastBackup = localStorage.getItem(LAST_BACKUP_KEY);
  
  document.getElementById('backupFrequency').value = frequency;
  document.getElementById('backupRetention').value = retention;
  
  if (lastBackup) {
    const date = new Date(parseInt(lastBackup));
    document.getElementById('lastBackupTime').textContent = date.toLocaleString();
  }
}

async function updateBackupFrequency() {
  const frequency = document.getElementById('backupFrequency').value;
  localStorage.setItem(BACKUP_FREQUENCY_KEY, frequency);
  await customAlert('Backup frequency updated. Changes will take effect when you return to the main page.', 'Settings Updated');
}

async function updateBackupRetention() {
  const retention = document.getElementById('backupRetention').value;
  localStorage.setItem(BACKUP_RETENTION_KEY, retention);
  await customAlert('Backup retention updated.', 'Settings Updated');
}

async function createManualBackup() {
  try {
    const backups = getBackups();
    const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
    
    const backup = {
      timestamp: Date.now(),
      data: getCurrentData(),
      goals: getCurrentGoals(),
      recentBooks: getCurrentBooks(),
      type: 'manual'
    };
    
    backups.push(backup);
    
    // Apply retention policy
    if (retention !== 'all') {
      const maxBackups = parseInt(retention);
      if (backups.length > maxBackups) {
        backups.sort((a, b) => b.timestamp - a.timestamp);
        backups.splice(maxBackups);
      }
    }
    
    localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
    localStorage.setItem(LAST_BACKUP_KEY, Date.now().toString());
    
    // Update display
    const date = new Date(backup.timestamp);
    document.getElementById('lastBackupTime').textContent = date.toLocaleString();
    
    await customAlert('Backup created successfully!', 'Backup Created');
  } catch (error) {
    console.error('Manual backup error:', error);
    await customAlert('Failed to create backup: ' + error.message, 'Backup Error');
  }
}

async function viewBackups() {
  const backups = getBackups();
  const container = document.getElementById('backupsList');
  
  if (backups.length === 0) {
    container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No backups available. Create a backup first!</div>';
  } else {
    // Sort by timestamp, newest first
    backups.sort((a, b) => b.timestamp - a.timestamp);
    
    container.innerHTML = '';
    backups.forEach((backup, index) => {
      const date = new Date(backup.timestamp);
      const backupDiv = document.createElement('div');
      backupDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 8px; border: 1px solid var(--border-color);';
      
      const entriesCount = backup.data ? backup.data.length : 0;
      const goalsCount = backup.goals ? backup.goals.length : 0;
      const type = backup.type === 'manual' ? 'üë§ Manual' : 'ü§ñ Automatic';
      
      backupDiv.innerHTML = `
        <div style="flex: 1;">
          <strong style="color: var(--text-primary);">${date.toLocaleString()}</strong><br>
          <span style="font-size: 12px; color: var(--text-secondary);">${type} ‚Ä¢ ${entriesCount} entries ‚Ä¢ ${goalsCount} goals</span>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn" onclick="restoreBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Restore</button>
          <button class="btn" onclick="downloadBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Download</button>
          <button class="danger-btn" onclick="deleteBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Delete</button>
        </div>
      `;
      
      container.appendChild(backupDiv);
    });
  }
  
  document.getElementById('viewBackupsModal').style.display = 'flex';
}

function closeViewBackupsModal() {
  document.getElementById('viewBackupsModal').style.display = 'none';
}

async function restoreBackup(index) {
  const backups = getBackups();
  if (index < 0 || index >= backups.length) {
    await customAlert('Backup not found.', 'Error');
    return;
  }
  
  const backup = backups[index];
  const date = new Date(backup.timestamp);
  
  const confirmed = await customConfirm(
    `Restore backup from ${date.toLocaleString()}?\n\nThis will replace your current data with the backup data.\n\nCurrent data will be lost unless you create a backup first.`,
    'Restore Backup'
  );
  
  if (!confirmed) return;
  
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(backup.data || []));
    localStorage.setItem(GOALS_KEY, JSON.stringify(backup.goals || []));
    localStorage.setItem(BOOKS_KEY, JSON.stringify(backup.recentBooks || []));
    
    closeViewBackupsModal();
    await customAlert('Backup restored successfully!\n\nReturn to the main page to see your restored data.', 'Restore Complete');
  } catch (error) {
    console.error('Restore error:', error);
    await customAlert('Failed to restore backup: ' + error.message, 'Restore Error');
  }
}

function downloadBackup(index) {
  const backups = getBackups();
  if (index < 0 || index >= backups.length) return;
  
  const backup = backups[index];
  const date = new Date(backup.timestamp);
  const dateStr = date.toISOString().split('T')[0];
  
  const exportData = {
    data: backup.data || [],
    goals: backup.goals || [],
    recentBooks: backup.recentBooks || [],
    backupDate: date.toISOString(),
    type: backup.type || 'manual'
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `reading-backup-${dateStr}-${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function deleteBackup(index) {
  const confirmed = await customConfirm(
    'Delete this backup?\n\nThis action cannot be undone.',
    'Delete Backup'
  );
  
  if (!confirmed) return;
  
  try {
    const backups = getBackups();
    backups.splice(index, 1);
    localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
    
    // Refresh the view
    viewBackups();
    await customAlert('Backup deleted successfully.', 'Backup Deleted');
  } catch (error) {
    console.error('Delete backup error:', error);
    await customAlert('Failed to delete backup: ' + error.message, 'Delete Error');
  }
}

// Load ttsu sync status
function loadTtsuSyncStatus() {
  const enabled = localStorage.getItem('ttsu_sync_enabled') === 'true';
  const folderId = localStorage.getItem('ttsu_folder_id');
  const lastSync = localStorage.getItem('ttsu_last_sync');
  
  const statusEl = document.getElementById('ttsuSyncStatusText');
  
  if (!enabled || !folderId) {
    statusEl.textContent = 'Not configured';
    statusEl.style.color = 'var(--text-secondary)';
    return;
  }
  
  if (!lastSync) {
    statusEl.textContent = 'Configured (not synced yet)';
    statusEl.style.color = 'var(--accent-color)';
    return;
  }
  
  const lastSyncDate = new Date(lastSync);
  const now = new Date();
  const diffMinutes = Math.floor((now - lastSyncDate) / 1000 / 60);
  
  if (diffMinutes < 1) {
    statusEl.textContent = 'Active (just synced)';
  } else if (diffMinutes < 60) {
    statusEl.textContent = `Active (synced ${diffMinutes} min ago)`;
  } else {
    statusEl.textContent = `Active (synced ${Math.floor(diffMinutes / 60)}h ago)`;
  }
  statusEl.style.color = 'var(--accent-color)';
}

async function disableTtsuSync() {
  const enabled = localStorage.getItem('ttsu_sync_enabled') === 'true';
  
  if (!enabled) {
    await customAlert('ttsu sync is already disabled.', 'Already Disabled');
    return;
  }
  
  const confirmed = await customConfirm(
    'Disable automatic ttsu sync from Google Drive?\n\nYou can re-enable it anytime.',
    'Disable Sync'
  );
  
  if (!confirmed) return;
  
  localStorage.removeItem('ttsu_sync_enabled');
  localStorage.removeItem('ttsu_folder_id');
  localStorage.removeItem('ttsu_access_token');
  localStorage.removeItem('ttsu_token_expiry');
  await customAlert('ttsu sync has been disabled.', 'Sync Disabled');
  loadTtsuSyncStatus();
}
    
    async function downloadData() {
  try {
    const exportData = {
      data: getCurrentData(),
      goals: getCurrentGoals(),
      recentBooks: getCurrentBooks(),
      exportDate: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `reading-heatmap-backup-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    await customAlert('Data exported successfully!', 'Export Complete');
  } catch (error) {
    await customAlert('Failed to export data: ' + error.message, 'Export Error');
  }
}

async function exportToToggl() {
  try {
    const data = getCurrentData();
    const togglData = data.map(entry => ({
      description: entry.title || 'Reading',
      start: `${entry.date}T00:00:00Z`,
      duration: entry.minutes * 60,
      tags: ['reading'],
      created_with: 'Reading Heatmap'
    }));
    
    const blob = new Blob([JSON.stringify(togglData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'reading-toggl-export.json';
    a.click();
    URL.revokeObjectURL(url);
    
    await customAlert('Exported to Toggl format! Import this file to Toggl Track.', 'Export Successful');
  } catch (error) {
    await customAlert('Failed to export: ' + error.message, 'Export Error');
  }
}

document.getElementById('fileInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const imported = JSON.parse(e.target.result);
      
      let importedData = [];
      let importedGoals = [];
      let importedBooks = [];
      
      if (Array.isArray(imported)) {
        importedData = imported;
      } else if (imported.data) {
        importedData = imported.data || [];
        importedGoals = imported.goals || [];
        importedBooks = imported.recentBooks || [];
      } else {
        await customAlert('Invalid data format.', 'Invalid File');
        return;
      }
      
      if (importedData.length === 0) {
        await customAlert('No data found in file.', 'Empty File');
        return;
      }
      
      const replace = await customConfirm(
        `Found ${importedData.length} reading entries.\n\nReplace existing data?\n\nClick OK to replace, or Cancel to merge with existing data.`,
        'Import Data'
      );
      
      const currentData = getCurrentData();
      const currentGoals = getCurrentGoals();
      const currentBooks = getCurrentBooks();
      
      if (replace) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(importedData));
        localStorage.setItem(GOALS_KEY, JSON.stringify(importedGoals));
        localStorage.setItem(BOOKS_KEY, JSON.stringify(importedBooks));
      } else {
        const mergedData = [...currentData, ...importedData];
        const mergedGoals = [...currentGoals, ...importedGoals];
        const mergedBooks = [...new Set([...currentBooks, ...importedBooks])];
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(mergedData));
        localStorage.setItem(GOALS_KEY, JSON.stringify(mergedGoals));
        localStorage.setItem(BOOKS_KEY, JSON.stringify(mergedBooks));
      }
      
      await customAlert('Data imported successfully! Return to the main page to see your data.', 'Import Successful');
    } catch (error) {
      await customAlert('Error reading file: ' + error.message, 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = '';
});

document.getElementById('ttsuInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const ttsuData = JSON.parse(e.target.result);
      
      if (!Array.isArray(ttsuData)) {
        await customAlert('Invalid ttsu export format. Expected an array of reading sessions.', 'Invalid Format');
        return;
      }
      
      const transformedData = [];
      const currentData = getCurrentData();
      const currentBooks = getCurrentBooks();
      const bookTitles = new Set();
      
      ttsuData.forEach(session => {
        if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
          return;
        }
        
        const date = session.dateKey;
        const minutes = Math.round(session.readingTime / 60);
        const characters = session.charactersRead || 0;
        
        if (minutes === 0 && characters === 0) return;
        
        const exists = currentData.some(entry => 
          entry.date === date && 
          entry.title === session.title &&
          Math.abs(entry.minutes - minutes) < 2 &&
          Math.abs(entry.characters - characters) < 100
        );
        
        if (!exists) {
          transformedData.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || 'Reading (from ttsu)'
          });
          bookTitles.add(session.title);
        }
      });
      
      if (transformedData.length === 0) {
        await customAlert('No new reading data found in ttsu export.\n\nAll sessions have either already been imported or contain no reading data.', 'No New Data');
        return;
      }
      
      const mergedData = [...currentData, ...transformedData];
      localStorage.setItem(STORAGE_KEY, JSON.stringify(mergedData));
      
      // Update recent books
      bookTitles.forEach(title => {
        if (title && !currentBooks.includes(title)) {
          currentBooks.unshift(title);
        }
      });
      const updatedBooks = currentBooks.slice(0, 10);
      localStorage.setItem(BOOKS_KEY, JSON.stringify(updatedBooks));
      
      const bookList = Array.from(bookTitles).join(', ');
      await customAlert(
        `‚úÖ Successfully imported ${transformedData.length} reading session(s) from ttsu!\n\nBooks: ${bookList}\n\nReturn to the main page to see your updated heatmap.`,
        'Import Successful'
      );
      
    } catch (error) {
      console.error('Import error:', error);
      await customAlert('Error importing ttsu data: ' + error.message + '\n\nPlease make sure you exported the correct JSON file from ttsu.', 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = '';
});

async function wipeAllData() {
  const firstConfirm = await customConfirm(
    'Are you sure? This will permanently delete all reading data, goals, and recent books.\n\nThis action cannot be undone.',
    'Wipe All Data'
  );
  
  if (!firstConfirm) return;
  
  const secondConfirm = await customConfirm(
    'Really delete ALL data? Click OK to confirm.',
    'Final Confirmation'
  );
  
  if (!secondConfirm) return;
  
  try {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(GOALS_KEY);
    localStorage.removeItem(BOOKS_KEY);
    localStorage.removeItem(BACKUPS_KEY); // Add this line
    
    await customAlert('All data has been wiped. Return to the main page to start fresh.', 'Data Wiped');
  } catch (error) {
    await customAlert('Failed to wipe data: ' + error.message, 'Error');
  }
} 
 window.onload = function() {
  loadTheme();
  loadStatVisibility();
  loadBackupSettings();
  loadTtsuSyncStatus();
    
  window.data = data = [];
  window.dailyData = dailyData = {};
  window.goals = goals = [];
  window.recentBooks = recentBooks = [];
  window.currentUser = currentUser = null;
  
  const storedUser = localStorage.getItem(USER_KEY);
  if (storedUser) {
    try {
      window.currentUser = currentUser = JSON.parse(storedUser);
    } catch (e) {
      console.error('Error loading stored user:', e);
    }
  }
  
  initializeAuthButton();
  renderHeatmap();
  updateStats();
  
  // Initialize automatic backups
  initializeBackups();
  
  // Check if redirected from settings page for ttsu sync
  const ttsuAction = sessionStorage.getItem('openTtsuSync');
  if (ttsuAction) {
    sessionStorage.removeItem('openTtsuSync');
    
    setTimeout(() => {
      openTtsuSyncSettings();
      
      // Auto-trigger the appropriate action
      setTimeout(async () => {
        if (ttsuAction === 'setup') {
          setupTtsuSync();
        } else if (ttsuAction === 'sync') {
          manualSyncTtsu();
        } else if (ttsuAction === 'batchLoad') {
          batchLoadAllTtsu();
        }
      }, 500);
    }, 1000);
  }
  
  if (window.location.protocol === 'file:') {
    setTimeout(async () => {
      await customAlert("Warning: Google Sign-In will NOT work if you open this file directly.\n\nPlease use a local server (e.g., Live Server in VS Code).", 'Warning');
    }, 500);
  }
};
    // Custom themed confirm dialog
function customConfirm(message, title = 'Confirm') {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    const titleEl = document.getElementById('confirmTitle');
    const messageEl = document.getElementById('confirmMessage');
    const okBtn = document.getElementById('confirmOk');
    const cancelBtn = document.getElementById('confirmCancel');
    
    titleEl.textContent = title;
    messageEl.textContent = message;
    modal.style.display = 'flex';
    
    const handleOk = () => {
      cleanup();
      resolve(true);
    };
    
    const handleCancel = () => {
      cleanup();
      resolve(false);
    };
    
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        cleanup();
        resolve(false);
      }
    };
    
    const cleanup = () => {
      modal.style.display = 'none';
      okBtn.removeEventListener('click', handleOk);
      cancelBtn.removeEventListener('click', handleCancel);
      document.removeEventListener('keydown', handleEscape);
    };
    
    okBtn.addEventListener('click', handleOk);
    cancelBtn.addEventListener('click', handleCancel);
    document.addEventListener('keydown', handleEscape);
  });
}

// Custom themed alert dialog
function customAlert(message, title = 'Notice') {
  return new Promise((resolve) => {
    const modal = document.getElementById('alertModal');
    const titleEl = document.getElementById('alertTitle');
    const messageEl = document.getElementById('alertMessage');
    const okBtn = document.getElementById('alertOk');
    
    titleEl.textContent = title;
    messageEl.textContent = message;
    modal.style.display = 'flex';
    
    const handleOk = () => {
      cleanup();
      resolve();
    };
    
    const handleEscape = (e) => {
      if (e.key === 'Escape' || e.key === 'Enter') {
        cleanup();
        resolve();
      }
    };
    
    const cleanup = () => {
      modal.style.display = 'none';
      okBtn.removeEventListener('click', handleOk);
      document.removeEventListener('keydown', handleEscape);
    };
    
    okBtn.addEventListener('click', handleOk);
    document.addEventListener('keydown', handleEscape);
    
    // Auto-focus OK button
    setTimeout(() => okBtn.focus(), 100);
  });
}

// ============================================
// ttsu Google Drive Auto-Sync Integration
// ============================================

const GDRIVE_CONFIG = {
  clientId: '510422773254-e8a8reeuce9jtn7dgjqq8c7kmeopikdr.apps.googleusercontent.com',
  apiKey: 'AIzaSyDOHQjTJYPXMQ-6p45ReF6dBRvmxUZ0P_k',
  scopes: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.metadata.readonly'
};

let googleAccessToken = null;
let tokenClient = null;

const TTSU_SYNC_ENABLED_KEY = 'ttsu_sync_enabled';
const TTSU_LAST_SYNC_KEY = 'ttsu_last_sync';
const TTSU_FOLDER_ID_KEY = 'ttsu_folder_id';
const TTSU_TOKEN_KEY = 'ttsu_access_token';
const TTSU_TOKEN_EXPIRY_KEY = 'ttsu_token_expiry';

let ttsuSyncInterval = null;

// Initialize GIS only (no GAPI needed)
function initGIS() {
  if (typeof google === 'undefined' || !google.accounts) {
    console.log('Google Identity Services not loaded yet');
    return false;
  }
  
  if (!tokenClient) {
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: GDRIVE_CONFIG.clientId,
      scope: GDRIVE_CONFIG.scopes,
      callback: '', // set during auth
    });
    console.log('GIS initialized');
  }
  return true;
}

// Direct REST API calls (no gapi.client needed)
async function driveApiCall(endpoint, accessToken) {
  const response = await fetch(`https://www.googleapis.com/drive/v3/${endpoint}`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Accept': 'application/json'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Drive API error: ${response.status} ${response.statusText}`);
  }
  
  return await response.json();
}

async function driveDownloadFile(fileId, accessToken) {
  const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });
  
  if (!response.ok) {
    throw new Error(`Download error: ${response.status}`);
  }
  
  return await response.text();
}

async function setupTtsuSync() {
  try {
    let attempts = 0;
    while (!initGIS() && attempts < 20) {
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }
    if (!tokenClient) throw new Error('Google Identity Services not loaded. Please refresh the page.');

    // Explicit consent only during setup
    const ok = await ensureDriveToken({ allowPrompt: true });
    if (!ok) throw new Error('Authorization failed. Please try again.');

    const folderId = await findTtsuFolder();
    if (!folderId) {
      await customAlert('Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!', 'Folder Not Found');
      return;
    }

    localStorage.setItem(TTSU_FOLDER_ID_KEY, folderId);
    localStorage.setItem(TTSU_SYNC_ENABLED_KEY, 'true');

    await syncFromTtsuGDrive();
    startAutoSync();

    loadTtsuSyncStatus();

    await customAlert('‚úÖ ttsu sync enabled! It will auto-sync every 5 minutes.', 'Sync Enabled');
  } catch (error) {
    console.error('Setup error:', error);
    await customAlert('Failed to setup ttsu sync:\n\n' + (error.message || JSON.stringify(error)), 'Setup Error');
  }
}

async function findTtsuFolder() {
  try {
    console.log('Searching for ttu-reader-data folder...');
    
    const data = await driveApiCall(`files?q=name='ttu-reader-data'&fields=files(id,name)&spaces=drive`, googleAccessToken);
    
    console.log('Search results:', data);
    
    if (data.files && data.files.length > 0) {
      console.log('Found folder:', data.files[0].name, 'ID:', data.files[0].id);
      return data.files[0].id;
    }
    
    console.log('Not found. Listing all folders...');
    const allFolders = await driveApiCall(`files?q=mimeType='application/vnd.google-apps.folder'&fields=files(id,name)&spaces=drive&pageSize=100`, googleAccessToken);
    
    console.log('All folders:', allFolders.files);
    
    return null;
  } catch (error) {
    console.error('Error finding ttsu folder:', error);
    return null;
  }
}

async function syncFromTtsuGDrive() {
  try {
    const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    if (!folderId) {
      throw new Error('ttsu folder not configured. Please run setup first.');
    }
    
    if (!googleAccessToken) {
      throw new Error('Not authenticated. Please run setup first.');
    }
    
    console.log('Fetching book folders from ttu-reader-data...');
    
    const bookFoldersQuery = encodeURIComponent(`'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
    const bookFoldersData = await driveApiCall(`files?q=${bookFoldersQuery}&spaces=drive&fields=files(id,name)&pageSize=100`, googleAccessToken);

    const bookFolders = bookFoldersData.files || [];
    console.log(`Found ${bookFolders.length} book folders`);
    
    if (bookFolders.length === 0) {
      console.log('No book folders found');
      return 0;
    }
    
    let totalImported = 0;
    const bookTitles = new Set();
    
    for (const bookFolder of bookFolders) {
      try {
        console.log(`Checking folder: ${bookFolder.name}`);
        
        const statsQuery = encodeURIComponent(`'${bookFolder.id}' in parents and name contains 'statistics' and mimeType='application/json'`);
        const statsData = await driveApiCall(`files?q=${statsQuery}&spaces=drive&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc`, googleAccessToken);
        
        const files = statsData.files || [];
        
        if (files.length === 0) {
          console.log(`No statistics file in ${bookFolder.name}`);
          continue;
        }
        
        const file = files[0];
        console.log(`Processing ${file.name}...`);
        
        const fileContent = await driveDownloadFile(file.id, googleAccessToken);
        const ttsuData = JSON.parse(fileContent);
        
        if (!Array.isArray(ttsuData)) continue;
        
        ttsuData.forEach(session => {
          if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
            return;
          }
          
          const date = session.dateKey;
          const minutes = Math.round(session.readingTime / 60);
          const characters = session.charactersRead || 0;
          
          if (minutes === 0 && characters === 0) return;
          
          const currentData = getCurrentData();
          const exists = currentData.some(entry => 
            entry.date === date && 
            entry.title === session.title &&
            Math.abs(entry.minutes - minutes) < 2 &&
            Math.abs(entry.characters - characters) < 100
          );
          
          if (!exists) {
            currentData.push({
              date: date,
              minutes: minutes,
              characters: characters,
              title: session.title || bookFolder.name || 'Reading'
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(currentData));
            totalImported++;
            bookTitles.add(session.title || bookFolder.name);
          }
        });
        
      } catch (fileError) {
        console.error('Error processing folder:', bookFolder.name, fileError);
      }
    }
    
    if (totalImported > 0) {
      const bookList = Array.from(bookTitles).join(', ');
      const confirmed = confirm(
        `Found ${totalImported} new reading session(s) from ttsu.\n\n` +
        `Books: ${bookList}\n\n` +
        `Import these sessions?`
      );
      
      if (!confirmed) {
        console.log('User cancelled ttsu import');
        return 0;
      }
      
      const currentBooks = getCurrentBooks();
      bookTitles.forEach(title => {
        if (title && !currentBooks.includes(title)) {
          currentBooks.unshift(title);
        }
      });
      const updatedBooks = currentBooks.slice(0, 10);
      localStorage.setItem(BOOKS_KEY, JSON.stringify(updatedBooks));
      
      console.log(`‚úÖ Synced ${totalImported} new sessions from ttsu`);
    }
    
    localStorage.setItem(TTSU_LAST_SYNC_KEY, new Date().toISOString());
    
    return totalImported;
    
  } catch (error) {
    console.error('Sync error:', error);
    throw error;
  }
}

async function batchLoadAllTtsu() {
  const firstConfirm = await customConfirm(
    '‚ö†Ô∏è BATCH LOAD ALL FROM TTSU ‚ö†Ô∏è\n\nThis will:\n1. Load ALL reading data from ttsu Google Drive\n2. OVERWRITE your existing data\n3. This action CANNOT be undone\n\nAre you sure you want to continue?',
    'Batch Load Warning'
  );
  
  if (!firstConfirm) return;
  
  const secondConfirm = await customConfirm(
    'FINAL CONFIRMATION\n\nYour current reading data will be PERMANENTLY REPLACED with all data from ttsu.\n\nClick OK to proceed or Cancel to abort.',
    'Final Confirmation'
  );
  
  if (!secondConfirm) return;
  
  try {
    const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    if (!folderId) {
      const hasToken = await ensureDriveToken({ allowPrompt: true });
      if (!hasToken) {
        throw new Error('Authorization failed. Please try again.');
      }
      
      const foundFolderId = await findTtsuFolder();
      if (!foundFolderId) {
        await customAlert(
          'Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!',
          'Folder Not Found'
        );
        return;
      }
      
      localStorage.setItem(TTSU_FOLDER_ID_KEY, foundFolderId);
    } else {
      const hasToken = await ensureDriveToken({ allowPrompt: false });
      if (!hasToken) {
        await customAlert(
          'Google Drive authorization has expired. Please press "Setup Sync" once to refresh authorization.',
          'Authorization Expired'
        );
        return;
      }
    }
    
    console.log('Starting batch load of all ttsu data...');
    
    const fId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    const bookFoldersQuery = encodeURIComponent(`'${fId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
    const bookFoldersData = await driveApiCall(`files?q=${bookFoldersQuery}&spaces=drive&fields=files(id,name)&pageSize=100`, googleAccessToken);

    const bookFolders = bookFoldersData.files || [];
    console.log(`Found ${bookFolders.length} book folders`);
    
    if (bookFolders.length === 0) {
      await customAlert('No book folders found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    const allData = [];
    let totalImported = 0;
    const bookTitles = new Set();
    
    for (const bookFolder of bookFolders) {
      try {
        console.log(`Processing folder: ${bookFolder.name}`);
        
        const statsQuery = encodeURIComponent(`'${bookFolder.id}' in parents and name contains 'statistics' and mimeType='application/json'`);
        const statsData = await driveApiCall(`files?q=${statsQuery}&spaces=drive&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc`, googleAccessToken);
        
        const files = statsData.files || [];
        
        if (files.length === 0) {
          console.log(`No statistics file in ${bookFolder.name}`);
          continue;
        }
        
        const file = files[0];
        console.log(`Processing ${file.name}...`);
        
        const fileContent = await driveDownloadFile(file.id, googleAccessToken);
        const ttsuData = JSON.parse(fileContent);
        
        if (!Array.isArray(ttsuData)) continue;
        
        ttsuData.forEach(session => {
          if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
            return;
          }
          
          const date = session.dateKey;
          const minutes = Math.round(session.readingTime / 60);
          const characters = session.charactersRead || 0;
          
          if (minutes === 0 && characters === 0) return;
          
          allData.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || bookFolder.name || 'Reading'
          });
          totalImported++;
          bookTitles.add(session.title || bookFolder.name);
        });
        
      } catch (fileError) {
        console.error('Error processing folder:', bookFolder.name, fileError);
      }
    }
    
    if (totalImported === 0) {
      await customAlert('No reading data found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
    
    const currentBooks = getCurrentBooks();
    bookTitles.forEach(title => {
      if (title && !currentBooks.includes(title)) {
        currentBooks.unshift(title);
      }
    });
    const updatedBooks = currentBooks.slice(0, 10);
    localStorage.setItem(BOOKS_KEY, JSON.stringify(updatedBooks));
    
    localStorage.setItem(TTSU_LAST_SYNC_KEY, new Date().toISOString());
    
    console.log(`‚úÖ Batch loaded ${totalImported} sessions from ttsu`);
    
    const bookList = Array.from(bookTitles).slice(0, 10).join(', ');
    const moreBooks = bookTitles.size > 10 ? `\n...and ${bookTitles.size - 10} more books` : '';
    
    await customAlert(
      `‚úÖ Batch Load Complete!\n\nImported: ${totalImported} reading sessions\nBooks: ${bookList}${moreBooks}\n\nYour data has been overwritten with ttsu data.`,
      'Success'
    );
    
    loadTtsuSyncStatus();
    
  } catch (error) {
    console.error('Batch load error:', error);
    await customAlert(
      'Failed to batch load from ttsu:\n\n' + (error.message || error),
      'Error'
    );
  }
}

function startAutoSync() {
  if (ttsuSyncInterval) {
    clearInterval(ttsuSyncInterval);
  }
  
  ttsuSyncInterval = setInterval(async () => {
    try {
      const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
      if (enabled) {
        console.log('Auto-syncing from ttsu...');
        await syncFromTtsuGDrive();
      }
    } catch (error) {
      console.error('Auto-sync error:', error);
    }
  }, 5 * 60 * 1000);
}

function stopAutoSync() {
  if (ttsuSyncInterval) {
    clearInterval(ttsuSyncInterval);
    ttsuSyncInterval = null;
  }
  localStorage.setItem(TTSU_SYNC_ENABLED_KEY, 'false');
}

async function manualSyncTtsu() {
  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);

  if (!enabled || !folderId) {
    await customAlert('ttsu sync is not enabled.\n\nPlease run "Setup Sync" once to configure.', 'Sync Not Enabled');
    return;
  }

  const hasToken = await ensureDriveToken({ allowPrompt: false });
  if (!hasToken) {
    await customAlert('Google Drive authorization has expired. Please press "Setup Sync" once to refresh authorization.', 'Authorization Expired');
    return;
  }

  try {
    const count = await syncFromTtsuGDrive();
    const lastSync = localStorage.getItem(TTSU_LAST_SYNC_KEY);
    const lastSyncStr = lastSync ? new Date(lastSync).toLocaleString() : 'Never';

    await customAlert(`‚úÖ Sync complete!\n\nNew sessions imported: ${count || 0}\nLast sync: ${lastSyncStr}`, 'Sync Complete');

    loadTtsuSyncStatus();
  } catch (error) {
    await customAlert('Sync failed:\n\n' + (error.message || error), 'Sync Error');
  }
}

async function ensureDriveToken(options = { allowPrompt: false }) {
  const storedToken = localStorage.getItem(TTSU_TOKEN_KEY);
  const storedExpiry = localStorage.getItem(TTSU_TOKEN_EXPIRY_KEY);
  
  if (storedToken && storedExpiry) {
    const expiryTime = parseInt(storedExpiry);
    const now = Date.now();
    
    if (expiryTime > now + (5 * 60 * 1000)) {
      googleAccessToken = storedToken;
      console.log('Using stored valid token');
      return true;
    }
  }
  
  try {
    await new Promise((resolve, reject) => {
      tokenClient.callback = (resp) => {
        if (resp && !resp.error && resp.access_token) {
          googleAccessToken = resp.access_token;
          
          const expiresIn = resp.expires_in || 3600;
          const expiryTime = Date.now() + (expiresIn * 1000);
          
          localStorage.setItem(TTSU_TOKEN_KEY, resp.access_token);
          localStorage.setItem(TTSU_TOKEN_EXPIRY_KEY, expiryTime.toString());
          
          console.log('Token refreshed and stored');
          resolve();
        } else {
          reject(resp?.error || new Error('silent_token_failed'));
        }
      };
      tokenClient.requestAccessToken({ prompt: '' });
    });
    return true;
  } catch (silentErr) {
    console.log('Silent token refresh failed:', silentErr);
    
    if (!options.allowPrompt) {
      localStorage.removeItem(TTSU_TOKEN_KEY);
      localStorage.removeItem(TTSU_TOKEN_EXPIRY_KEY);
      return false;
    }

    try {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp && !resp.error && resp.access_token) {
            googleAccessToken = resp.access_token;
            
            const expiresIn = resp.expires_in || 3600;
            const expiryTime = Date.now() + (expiresIn * 1000);
            
            localStorage.setItem(TTSU_TOKEN_KEY, resp.access_token);
            localStorage.setItem(TTSU_TOKEN_EXPIRY_KEY, expiryTime.toString());
            
            console.log('Token obtained via consent and stored');
            resolve();
          } else {
            reject(resp?.error || new Error('prompt_token_failed'));
          }
        };
        tokenClient.requestAccessToken({ prompt: 'consent' });
      });
      return true;
    } catch (promptErr) {
      localStorage.removeItem(TTSU_TOKEN_KEY);
      localStorage.removeItem(TTSU_TOKEN_EXPIRY_KEY);
      return false;
    }
  }
}

// Initialize on load
setTimeout(async () => {
  initGIS();

  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);

  if (enabled && folderId) {
    await ensureDriveToken({ allowPrompt: false });
    startAutoSync();
    loadTtsuSyncStatus();
    console.log('ttsu auto-sync initialized on load');
  }
}, 1000);
  </script>

<!-- View Backups Modal -->
<div class="modal" id="viewBackupsModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 700px; max-width: 90vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Available Backups</h2>
    <div id="backupsList" style="margin-top: 16px;"></div>
    <button class="btn" onclick="closeViewBackupsModal()" style="width: 100%; margin-top: 16px;">Close</button>
  </div>
</div>

<!-- Custom Confirmation Modal -->
<div class="modal" id="confirmModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 460px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 id="confirmTitle" style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Confirm</h2>
    <p id="confirmMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0;"></p>
    <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
      <button class="btn" id="confirmCancel">Cancel</button>
      <button class="confirm-btn" id="confirmOk">OK</button>
    </div>
  </div>
</div>

<!-- Custom Alert Modal -->
<div class="modal" id="alertModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 460px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 id="alertTitle" style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Notice</h2>
    <p id="alertMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0; white-space: pre-line;"></p>
    <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
      <button class="confirm-btn" id="alertOk" style="width: 100%;">OK</button>
    </div>
  </div>
</div>

</body>
</html>