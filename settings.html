<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Settings - Ë™≠Êõ∏ track</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23ffffff'/%3E%3Cpath d='M25 20 L25 80 L50 75 L75 80 L75 20 L50 25 Z' fill='%23000000'/%3E%3Cline x1='50' y1='25' x2='50' y2='75' stroke='%23ffffff' stroke-width='2'/%3E%3Cline x1='32' y1='35' x2='45' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='43' x2='45' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='51' x2='45' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='32' y1='59' x2='45' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='35' x2='68' y2='35' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='43' x2='68' y2='43' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='51' x2='68' y2='51' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3Cline x1='55' y1='59' x2='68' y2='59' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Klee+One:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="ttsu-sync.js" defer></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border-color: #30363d;
      --text-primary: #c9d1d9;
      --text-secondary: #8b949e;
      --accent-color: #238636;
      --accent-hover: #2ea043;
      --danger-color: #da3633;
      --danger-hover: #f85149;
    }
    
    body.theme-nord {
      --bg-primary: #2e3440;
      --bg-secondary: #3b4252;
      --bg-tertiary: #434c5e;
      --border-color: #4c566a;
      --text-primary: #eceff4;
      --text-secondary: #d8dee9;
      --accent-color: #88c0d0;
      --accent-hover: #8fbcbb;
      --danger-color: #bf616a;
      --danger-hover: #d08770;
    }

    body.theme-tokyo {
      --bg-primary: #1a1b26;
      --bg-secondary: #16161e;
      --bg-tertiary: #24283b;
      --border-color: #414868;
      --text-primary: #a9b1d6;
      --text-secondary: #565f89;
      --accent-color: #7aa2f7;
      --accent-hover: #7dcfff;
      --danger-color: #f7768e;
      --danger-hover: #ff9e64;
    }

    body.theme-dracula {
      --bg-primary: #282a36;
      --bg-secondary: #21222c;
      --bg-tertiary: #343746;
      --border-color: #44475a;
      --text-primary: #f8f8f2;
      --text-secondary: #6272a4;
      --accent-color: #ff5555;
      --accent-hover: #ff6e6e;
      --danger-color: #ff5555;
      --danger-hover: #ff6e6e;
    }

    body.theme-everforest {
      --bg-primary: #fdf6e3;
      --bg-secondary: #f4f0d9;
      --bg-tertiary: #efebd4;
      --border-color: #e0dcc7;
      --text-primary: #5c6a72;
      --text-secondary: #939f91;
      --accent-color: #8da101;
      --accent-hover: #a7b901;
      --danger-color: #f85552;
      --danger-hover: #e66868;
    }

    body.theme-onedark {
      --bg-primary: #282c34;
      --bg-secondary: #21252b;
      --bg-tertiary: #2c313c;
      --border-color: #3e4451;
      --text-primary: #abb2bf;
      --text-secondary: #5c6370;
      --accent-color: #98c379;
      --accent-hover: #b5cea8;
      --danger-color: #e06c75;
      --danger-hover: #be5046;
    }

    body.theme-nord-light {
      --bg-primary: #eceff4;
      --bg-secondary: #e5e9f0;
      --bg-tertiary: #d8dee9;
      --border-color: #c2c9d6;
      --text-primary: #2e3440;
      --text-secondary: #4c566a;
      --accent-color: #5e81ac;
      --accent-hover: #81a1c1;
      --danger-color: #bf616a;
      --danger-hover: #d08770;
    }

    body.theme-phoenix {
      --bg-primary: #170f1e;
      --bg-secondary: #1c1521;
      --bg-tertiary: #2b2032;
      --border-color: #3d2f47;
      --text-primary: #f5c2e7;
      --text-secondary: #988ba2;
      --accent-color: #cba6f7;
      --accent-hover: #d4b4f8;
      --danger-color: #f38ba8;
      --danger-hover: #f5a7bc;
    }

    body.theme-ereader {
      --bg-primary: #ffffff;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #e8e8e8;
      --border-color: #d0d0d0;
      --text-primary: #000000;
      --text-secondary: #666666;
      --accent-color: #333333;
      --accent-hover: #000000;
      --danger-color: #555555;
      --danger-hover: #333333;
    }
    
    body {
      font-family: "Klee One", cursive;
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 40px 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }
    
    h1 {
      font-size: 24px;
      font-weight: 700;
      color: #ffffff;
    }
    
    body.theme-everforest h1,
    body.theme-nord-light h1,
    body.theme-ereader h1 {
      color: var(--text-primary);
    }
    
    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-block;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .btn:hover {
      background: var(--border-color);
      border-color: var(--text-secondary);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
    
    .settings-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }
    
    .settings-section h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: var(--text-primary);
    }
    
    .settings-section p {
      color: var(--text-secondary);
      font-size: 13px;
      margin-bottom: 16px;
      line-height: 1.6;
    }
    
    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-color);
    }
    
    .setting-item:last-child {
      border-bottom: none;
    }
    
    .setting-label {
      flex: 1;
    }
    
    .setting-label h3 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .setting-label p {
      font-size: 12px;
      color: var(--text-secondary);
      margin: 0;
    }
    
    .form-input, select {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }
    
    .form-input:focus, select:focus {
      outline: none;
      border-color: var(--accent-color);
    }
    
    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .confirm-btn {
      background: var(--border-color);
      border: 1px solid var(--text-secondary);
      color: var(--text-primary);
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    
    .confirm-btn:hover {
      background: var(--text-secondary);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
      transform: translateY(-1px);
    }
    
    .danger-btn {
      background: var(--danger-color);
      border: 1px solid var(--danger-color);
      color: #ffffff;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .danger-btn:hover {
      background: var(--danger-hover);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚öôÔ∏è Settings</h1>
      <a href="index.html" class="btn">‚Üê Back to Heatmap</a>
    </header>
    
    <!-- Statistics Visibility -->
    <div class="settings-section">
      <h2>üìä Statistics Display</h2>
      <p>Choose which statistics to show on the main heatmap panel.</p>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showLongestStreak" onchange="toggleStat('longestStreak')" checked>
          <span style="margin-left: 8px;">Longest streak</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showCurrentStreak" onchange="toggleStat('currentStreak')" checked>
          <span style="margin-left: 8px;">Current streak</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showAverage" onchange="toggleStat('average')" checked>
          <span style="margin-left: 8px;">Average</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showAvgSpeed" onchange="toggleStat('avgSpeed')" checked>
          <span style="margin-left: 8px;">Average speed</span>
        </label>
      </div>
      
      <div class="setting-item">
        <label class="setting-label">
          <input type="checkbox" id="showTotal" onchange="toggleStat('total')" checked>
          <span style="margin-left: 8px;">Total</span>
        </label>
      </div>
    </div>
    
    <!-- Backup Settings -->
    <div class="settings-section">
      <h2>üíæ Automatic Backups</h2>
      <p>Automatically save backup copies of your reading data to protect against data loss.</p>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Backup Frequency</h3>
          <p>How often to create automatic backups</p>
        </div>
        <select id="backupFrequency" onchange="updateBackupFrequency()">
          <option value="none">Disabled</option>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Keep Last</h3>
          <p>Number of backups to keep</p>
        </div>
        <select id="backupRetention" onchange="updateBackupRetention()">
          <option value="3">3 backups</option>
          <option value="5">5 backups</option>
          <option value="10">10 backups</option>
          <option value="20">20 backups</option>
          <option value="all">All backups</option>
        </select>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Last Backup</h3>
          <p id="lastBackupTime">Never</p>
        </div>
        <div class="action-buttons">
          <button class="confirm-btn" onclick="createManualBackup()">Backup Now</button>
          <button class="btn" onclick="viewBackups()">View Backups</button>
        </div>
      </div>
    </div>
    
<!-- ttsu Sync Settings -->
<div class="settings-section">
  <h2>üîÑ ttsu Google Drive Sync</h2>
  <p>Automatically sync your reading data from the ttsu app via Google Drive.</p>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Sync Status</h3>
      <p id="ttsuSyncStatusText">Not configured</p>
    </div>
    <div class="action-buttons">
      <button class="confirm-btn" onclick="setupTtsuSync()">Setup Sync</button>
      <button class="btn" onclick="manualSyncTtsu()">Sync Now</button>
    </div>
  </div>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Batch Load</h3>
      <p>Load all ttsu data (overwrites existing data)</p>
    </div>
    <button class="btn" onclick="batchLoadAllTtsu()"">üì• Batch Load All</button>
  </div>
  
  <div class="setting-item">
    <div class="setting-label">
      <h3>Disable Sync</h3>
      <p>Stop automatic syncing from ttsu</p>
    </div>
    <button class="danger-btn" onclick="disableTtsuSync()">Disable</button>
  </div>
</div>
    
    <!-- Data Management -->
    <div class="settings-section">
      <h2>üìÇ Data Management</h2>
      <p>Import, export, and manage your reading data.</p>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Export Data</h3>
          <p>Download your data as JSON or export to Toggl format</p>
        </div>
        <div class="action-buttons">
          <button class="btn" onclick="downloadData()">üíæ Download JSON</button>
          <button class="btn" onclick="exportToToggl()">‚è±Ô∏è Export to Toggl</button>
        </div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Import Data</h3>
          <p>Load data from JSON file or ttsu export</p>
        </div>
        <div class="action-buttons">
          <button class="btn" onclick="document.getElementById('fileInput').click()">üìÇ Load JSON</button>
          <button class="btn" onclick="document.getElementById('ttsuInput').click()">üìö Import ttsu</button>
        </div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          <h3>Wipe All Data</h3>
          <p style="color: var(--danger-color);">‚ö†Ô∏è Permanently delete all reading data</p>
        </div>
        <button class="danger-btn" onclick="wipeAllData()">üóëÔ∏è Wipe All Data</button>
      </div>
    </div>
  </div>
  
  <input type="file" id="fileInput" style="display: none;" accept=".json">
  <input type="file" id="ttsuInput" style="display: none;" accept=".json">
  
<script>
  // Load theme
  const THEME_KEY = 'reading_heatmap_theme';
  const STORAGE_KEY = 'reading_heatmap_data';
  const GOALS_KEY = 'reading_heatmap_goals';
  const BOOKS_KEY = 'reading_heatmap_books';
  const USER_KEY = 'reading_heatmap_user';
  const BACKUPS_KEY = 'reading_heatmap_backups';
  
  const theme = localStorage.getItem(THEME_KEY) || 'default';
  document.body.className = theme === 'default' ? '' : `theme-${theme}`;
  
  // Helper to get current data from localStorage OR from window (if available from Firebase)
  function getCurrentData() {
    // Try to get from window first (Firebase data)
    if (window.opener && window.opener.data && Array.isArray(window.opener.data) && window.opener.data.length > 0) {
      return window.opener.data;
    }
    // Fallback to localStorage
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getCurrentGoals() {
    if (window.opener && window.opener.goals && Array.isArray(window.opener.goals)) {
      return window.opener.goals;
    }
    try {
      const stored = localStorage.getItem(GOALS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getCurrentBooks() {
    if (window.opener && window.opener.recentBooks && Array.isArray(window.opener.recentBooks)) {
      return window.opener.recentBooks;
    }
    try {
      const stored = localStorage.getItem(BOOKS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (e) {
      return [];
    }
  }
  
  function getBackups() {
    try {
      const stored = localStorage.getItem(BACKUPS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Error loading backups:', error);
      return [];
    }
  }
    
  // Load stat visibility settings
  function loadStatVisibility() {
    const stats = ['longestStreak', 'currentStreak', 'average', 'avgSpeed', 'total'];
    stats.forEach(stat => {
      const saved = localStorage.getItem(`show_${stat}`);
      if (saved !== null) {
        const checkbox = document.getElementById(`show${stat.charAt(0).toUpperCase() + stat.slice(1)}`);
        if (checkbox) {
          checkbox.checked = saved === 'true';
        }
      }
    });
  }
  
  function toggleStat(statName) {
    const checkbox = document.getElementById(`show${statName.charAt(0).toUpperCase() + statName.slice(1)}`);
    localStorage.setItem(`show_${statName}`, checkbox.checked);
  }
  
  // Load backup settings
  const BACKUP_FREQUENCY_KEY = 'reading_heatmap_backup_frequency';
  const BACKUP_RETENTION_KEY = 'reading_heatmap_backup_retention';
  const LAST_BACKUP_KEY = 'reading_heatmap_last_backup';

  function loadBackupSettings() {
    const frequency = localStorage.getItem(BACKUP_FREQUENCY_KEY) || 'none';
    const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';
    const lastBackup = localStorage.getItem(LAST_BACKUP_KEY);
    
    const freqSelect = document.getElementById('backupFrequency');
    const retSelect = document.getElementById('backupRetention');
    
    if (freqSelect) freqSelect.value = frequency;
    if (retSelect) retSelect.value = retention;
    
    if (lastBackup) {
      const date = new Date(parseInt(lastBackup));
      const timeEl = document.getElementById('lastBackupTime');
      if (timeEl) {
        timeEl.textContent = date.toLocaleString();
      }
    }
  }

  async function updateBackupFrequency() {
    const frequency = document.getElementById('backupFrequency').value;
    localStorage.setItem(BACKUP_FREQUENCY_KEY, frequency);
    await customAlert('Backup frequency updated to: ' + frequency, 'Settings Updated');
  }

  async function updateBackupRetention() {
    const retention = document.getElementById('backupRetention').value;
    localStorage.setItem(BACKUP_RETENTION_KEY, retention);
    await customAlert('Backup retention updated to: ' + retention + ' backups', 'Settings Updated');
  }

  async function createManualBackup() {
    try {
      const backups = getBackups();
      const retention = localStorage.getItem(BACKUP_RETENTION_KEY) || '5';

      const backup = {
        timestamp: Date.now(),
        data: getCurrentData(),
        goals: getCurrentGoals(),
        recentBooks: getCurrentBooks(),
        type: 'manual'
      };

      backups.push(backup);
      backups.sort((a, b) => b.timestamp - a.timestamp);
      if (retention !== 'all') {
        const maxBackups = parseInt(retention);
        if (backups.length > maxBackups) {
          backups.splice(maxBackups);
        }
      }

      localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
      localStorage.setItem(LAST_BACKUP_KEY, String(backup.timestamp));

      const date = new Date(backup.timestamp);
      const timeEl = document.getElementById('lastBackupTime');
      if (timeEl) timeEl.textContent = date.toLocaleString();

      await customAlert(`Backup created successfully!\n\n${backup.data.length} entries backed up`, 'Backup Created');
    } catch (error) {
      console.error('Manual backup error:', error);
      await customAlert('Failed to create backup: ' + error.message, 'Backup Error');
    }
  }

  async function viewBackups() {
    const backups = getBackups();
    const container = document.getElementById('backupsList');
    
    if (backups.length === 0) {
      container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No backups available. Create a backup first!</div>';
    } else {
      backups.sort((a, b) => b.timestamp - a.timestamp);
      
      container.innerHTML = '';
      backups.forEach((backup, index) => {
        const date = new Date(backup.timestamp);
        const backupDiv = document.createElement('div');
        backupDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 8px; border: 1px solid var(--border-color);';
        
        const entriesCount = backup.data ? backup.data.length : 0;
        const goalsCount = backup.goals ? backup.goals.length : 0;
        const booksCount = backup.recentBooks ? backup.recentBooks.length : 0;
        const type = backup.type === 'manual' ? 'üë§ Manual' : 'ü§ñ Automatic';
        
        backupDiv.innerHTML = `
          <div style="flex: 1;">
            <strong style="color: var(--text-primary);">${date.toLocaleString()}</strong><br>
            <span style="font-size: 12px; color: var(--text-secondary);">${type} ‚Ä¢ ${entriesCount} entries ‚Ä¢ ${goalsCount} goals ‚Ä¢ ${booksCount} books</span>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" onclick="restoreBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Restore</button>
            <button class="btn" onclick="downloadBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Download</button>
            <button class="danger-btn" onclick="deleteBackup(${index})" style="padding: 6px 12px; font-size: 12px;">Delete</button>
          </div>
        `;
        
        container.appendChild(backupDiv);
      });
    }
    
    document.getElementById('viewBackupsModal').style.display = 'flex';
  }

  function closeViewBackupsModal() {
    document.getElementById('viewBackupsModal').style.display = 'none';
  }

  async function restoreBackup(index) {
    const backups = getBackups();
    if (index < 0 || index >= backups.length) {
      await customAlert('Backup not found.', 'Error');
      return;
    }
    
    const backup = backups[index];
    const date = new Date(backup.timestamp);
    
    const confirmed = await customConfirm(
      `Restore backup from ${date.toLocaleString()}?\n\nThis will replace your current data with the backup data.\n\nCurrent data will be lost unless you create a backup first.`,
      'Restore Backup'
    );
    
    if (!confirmed) return;
    
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(backup.data || []));
      localStorage.setItem(GOALS_KEY, JSON.stringify(backup.goals || []));
      localStorage.setItem(BOOKS_KEY, JSON.stringify(backup.recentBooks || []));
      
      sessionStorage.setItem('just_restored_backup', 'true');
      
      closeViewBackupsModal();
      await customAlert('Backup restored successfully!\n\nRedirecting to main page...', 'Restore Complete');
      
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 500);
    } catch (error) {
      console.error('Restore error:', error);
      await customAlert('Failed to restore backup: ' + error.message, 'Restore Error');
    }
  }

  function downloadBackup(index) {
    const backups = getBackups();
    if (index < 0 || index >= backups.length) return;
    
    const backup = backups[index];
    const date = new Date(backup.timestamp);
    const dateStr = date.toISOString().split('T')[0];
    
    const exportData = {
      data: backup.data || [],
      goals: backup.goals || [],
      recentBooks: backup.recentBooks || [],
      backupDate: date.toISOString(),
      type: backup.type || 'manual'
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `reading-backup-${dateStr}-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function deleteBackup(index) {
    const confirmed = await customConfirm(
      'Delete this backup?\n\nThis action cannot be undone.',
      'Delete Backup'
    );
    
    if (!confirmed) return;
    
    try {
      const backups = getBackups();
      backups.splice(index, 1);
      localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups));
      
      const latest = backups.sort((a,b)=>b.timestamp-a.timestamp)[0];
      localStorage.setItem(LAST_BACKUP_KEY, latest ? String(latest.timestamp) : '');
      loadBackupSettings();
      
      viewBackups();
      await customAlert('Backup deleted successfully.', 'Backup Deleted');
    } catch (error) {
      console.error('Delete backup error:', error);
      await customAlert('Failed to delete backup: ' + error.message, 'Delete Error');
    }
  }

  function loadTtsuSyncStatus() {
    const enabled = localStorage.getItem('ttsu_sync_enabled') === 'true';
    const folderId = localStorage.getItem('ttsu_folder_id');
    const lastSync = localStorage.getItem('ttsu_last_sync');
    
    const statusEl = document.getElementById('ttsuSyncStatusText');
    
    if (!enabled || !folderId) {
      statusEl.textContent = 'Not configured';
      statusEl.style.color = 'var(--text-secondary)';
      return;
    }
    
    if (!lastSync) {
      statusEl.textContent = 'Configured (not synced yet)';
      statusEl.style.color = 'var(--accent-color)';
      return;
    }
    
    const lastSyncDate = new Date(lastSync);
    const now = new Date();
    const diffMinutes = Math.floor((now - lastSyncDate) / 1000 / 60);
    
    if (diffMinutes < 1) {
      statusEl.textContent = 'Active (just synced)';
    } else if (diffMinutes < 60) {
      statusEl.textContent = `Active (synced ${diffMinutes} min ago)`;
    } else {
      statusEl.textContent = `Active (synced ${Math.floor(diffMinutes / 60)}h ago)`;
    }
    statusEl.style.color = 'var(--accent-color)';
  }

  async function disableTtsuSync() {
    const enabled = localStorage.getItem('ttsu_sync_enabled') === 'true';
    
    if (!enabled) {
      await customAlert('ttsu sync is already disabled.', 'Already Disabled');
      return;
    }
    
    const confirmed = await customConfirm(
      'Disable automatic ttsu sync from Google Drive?\n\nYou can re-enable it anytime.',
      'Disable Sync'
    );
    
    if (!confirmed) return;
    
    localStorage.removeItem('ttsu_sync_enabled');
    localStorage.removeItem('ttsu_folder_id');
    localStorage.removeItem('ttsu_access_token');
    localStorage.removeItem('ttsu_token_expiry');
    await customAlert('ttsu sync has been disabled.', 'Sync Disabled');
    loadTtsuSyncStatus();
  }
  
  async function downloadData() {
    try {
      const exportData = {
        data: getCurrentData(),
        goals: getCurrentGoals(),
        recentBooks: getCurrentBooks(),
        exportDate: new Date().toISOString()
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `reading-heatmap-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      await customAlert('Data exported successfully!', 'Export Complete');
    } catch (error) {
      await customAlert('Failed to export data: ' + error.message, 'Export Error');
    }
  }
async function setupTtsuSync() {
  try {
    let attempts = 0;
    while (!initGIS() && attempts < 20) {
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }
    if (!tokenClient) throw new Error('Google Identity Services not loaded. Please refresh the page.');

    const ok = await ensureDriveToken({ allowPrompt: true });
    if (!ok) throw new Error('Authorization failed. Please try again.');

    const folderId = await findTtsuFolder();
    if (!folderId) {
      await customAlert('Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!', 'Folder Not Found');
      return;
    }

    localStorage.setItem(TTSU_FOLDER_ID_KEY, folderId);
    localStorage.setItem(TTSU_SYNC_ENABLED_KEY, 'true');

    await syncFromTtsuGDrive();
    startAutoSync();

    loadTtsuSyncStatus();

    await customAlert('‚úÖ ttsu sync enabled! It will auto-sync every 5 minutes.', 'Sync Enabled');
  } catch (error) {
    console.error('Setup error:', error);
    await customAlert('Failed to setup ttsu sync:\n\n' + (error.message || JSON.stringify(error)), 'Setup Error');
  }
}

async function manualSyncTtsu() {
  const enabled = localStorage.getItem(TTSU_SYNC_ENABLED_KEY) === 'true';
  const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);

  if (!enabled || !folderId) {
    await customAlert('ttsu sync is not enabled.\n\nPlease run "Setup Sync" once to configure.', 'Sync Not Enabled');
    return;
  }

  const hasToken = await ensureDriveToken({ allowPrompt: false });
  if (!hasToken) {
    await customAlert('Google Drive authorization has expired. Please press "Setup Sync" once to refresh authorization.', 'Authorization Expired');
    return;
  }

  try {
    const count = await syncFromTtsuGDrive();
    const lastSync = localStorage.getItem(TTSU_LAST_SYNC_KEY);
    const lastSyncStr = lastSync ? new Date(lastSync).toLocaleString() : 'Never';

    await customAlert(`‚úÖ Sync complete!\n\nNew sessions imported: ${count || 0}\nLast sync: ${lastSyncStr}`, 'Sync Complete');

    loadTtsuSyncStatus();
  } catch (error) {
    await customAlert('Sync failed:\n\n' + (error.message || error), 'Sync Error');
  }
}

async function batchLoadAllTtsu() {
  const firstConfirm = await customConfirm(
    '‚ö†Ô∏è BATCH LOAD ALL FROM TTSU ‚ö†Ô∏è\n\nThis will:\n1. Load ALL reading data from ttsu Google Drive\n2. OVERWRITE your existing data\n3. This action CANNOT be undone\n\nAre you sure you want to continue?',
    'Batch Load Warning'
  );
  
  if (!firstConfirm) return;
  
  const secondConfirm = await customConfirm(
    'FINAL CONFIRMATION\n\nYour current reading data will be PERMANENTLY REPLACED with all data from ttsu.\n\nClick OK to proceed or Cancel to abort.',
    'Final Confirmation'
  );
  
  if (!secondConfirm) return;
  
  try {
    const folderId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    if (!folderId) {
      const hasToken = await ensureDriveToken({ allowPrompt: true });
      if (!hasToken) {
        throw new Error('Authorization failed. Please try again.');
      }
      
      const foundFolderId = await findTtsuFolder();
      if (!foundFolderId) {
        await customAlert(
          'Could not find ttsu data folder in Google Drive.\n\nMake sure ttsu has exported data first!',
          'Folder Not Found'
        );
        return;
      }
      
      localStorage.setItem(TTSU_FOLDER_ID_KEY, foundFolderId);
    } else {
      const hasToken = await ensureDriveToken({ allowPrompt: false });
      if (!hasToken) {
        await customAlert(
          'Google Drive authorization has expired. Please press "Setup Sync" once to refresh authorization.',
          'Authorization Expired'
        );
        return;
      }
    }
    
    console.log('Starting batch load of all ttsu data...');
    
    const fId = localStorage.getItem(TTSU_FOLDER_ID_KEY);
    
    const bookFoldersQuery = encodeURIComponent(`'${fId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
    const bookFoldersData = await driveApiCall(`files?q=${bookFoldersQuery}&spaces=drive&fields=files(id,name)&pageSize=100`, googleAccessToken);

    const bookFolders = bookFoldersData.files || [];
    console.log(`Found ${bookFolders.length} book folders`);
    
    if (bookFolders.length === 0) {
      await customAlert('No book folders found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    const allData = [];
    let totalImported = 0;
    const bookTitles = new Set();
    
    for (const bookFolder of bookFolders) {
      try {
        console.log(`Processing folder: ${bookFolder.name}`);
        
        const statsQuery = encodeURIComponent(`'${bookFolder.id}' in parents and name contains 'statistics' and mimeType='application/json'`);
        const statsData = await driveApiCall(`files?q=${statsQuery}&spaces=drive&fields=files(id,name,modifiedTime)&orderBy=modifiedTime desc`, googleAccessToken);
        
        const files = statsData.files || [];
        
        if (files.length === 0) {
          console.log(`No statistics file in ${bookFolder.name}`);
          continue;
        }
        
        const file = files[0];
        console.log(`Processing ${file.name}...`);
        
        const fileContent = await driveDownloadFile(file.id, googleAccessToken);
        const ttsuData = JSON.parse(fileContent);
        
        if (!Array.isArray(ttsuData)) continue;
        
        ttsuData.forEach(session => {
          if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
            return;
          }
          
          const date = session.dateKey;
          const minutes = Math.round(session.readingTime / 60);
          const characters = session.charactersRead || 0;
          
          if (minutes === 0 && characters === 0) return;
          
          allData.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || bookFolder.name || 'Reading'
          });
          totalImported++;
          bookTitles.add(session.title || bookFolder.name);
        });
        
      } catch (fileError) {
        console.error('Error processing folder:', bookFolder.name, fileError);
      }
    }
    
    if (totalImported === 0) {
      await customAlert('No reading data found in ttsu Google Drive.', 'No Data Found');
      return;
    }
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
    
    const currentBooks = getCurrentBooks();
    bookTitles.forEach(title => {
      if (title && !currentBooks.includes(title)) {
        currentBooks.unshift(title);
      }
    });
    const updatedBooks = currentBooks.slice(0, 10);
    localStorage.setItem(BOOKS_KEY, JSON.stringify(updatedBooks));
    
    localStorage.setItem(TTSU_LAST_SYNC_KEY, new Date().toISOString());
    
    console.log(`‚úÖ Batch loaded ${totalImported} sessions from ttsu`);
    
    const bookList = Array.from(bookTitles).slice(0, 10).join(', ');
    const moreBooks = bookTitles.size > 10 ? `\n...and ${bookTitles.size - 10} more books` : '';
    
    await customAlert(
      `‚úÖ Batch Load Complete!\n\nImported: ${totalImported} reading sessions\nBooks: ${bookList}${moreBooks}\n\nYour data has been overwritten with ttsu data.`,
      'Success'
    );
    
    loadTtsuSyncStatus();
    
  } catch (error) {
    console.error('Batch load error:', error);
    await customAlert(
      'Failed to batch load from ttsu:\n\n' + (error.message || error),
      'Error'
    );
  }
}


  async function exportToToggl() {
    try {
      const data = getCurrentData();
      const togglData = data.map(entry => ({
        description: entry.title || 'Reading',
        start: `${entry.date}T00:00:00Z`,
        duration: entry.minutes * 60,
        tags: ['reading'],
        created_with: 'Reading Heatmap'
      }));
      
      const blob = new Blob([JSON.stringify(togglData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'reading-toggl-export.json';
      a.click();
      URL.revokeObjectURL(url);
      
      await customAlert('Exported to Toggl format! Import this file to Toggl Track.', 'Export Successful');
    } catch (error) {
      await customAlert('Failed to export: ' + error.message, 'Export Error');
    }
  }

 document.getElementById('fileInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const imported = JSON.parse(e.target.result);
      
      let importedData = [];
      let importedGoals = [];
      let importedBooks = [];
      
      if (Array.isArray(imported)) {
        importedData = imported;
      } else if (imported.data) {
        importedData = imported.data || [];
        importedGoals = imported.goals || [];
        importedBooks = imported.recentBooks || [];
      } else {
        await customAlert('Invalid data format.', 'Invalid File');
        return;
      }
      
      if (importedData.length === 0) {
        await customAlert('No data found in file.', 'Empty File');
        return;
      }
      
      const replace = await customConfirm(
        `Found ${importedData.length} reading entries.\n\nReplace existing data?\n\nClick OK to replace, or Cancel to merge with existing data.`,
        'Import Data'
      );
      
      const currentData = getCurrentData();
      const currentGoals = getCurrentGoals();
      const currentBooks = getCurrentBooks();
      
      if (replace) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(importedData));
        localStorage.setItem(GOALS_KEY, JSON.stringify(importedGoals));
        localStorage.setItem(BOOKS_KEY, JSON.stringify(importedBooks));
      } else {
        const mergedData = [...currentData, ...importedData];
        const mergedGoals = [...currentGoals, ...importedGoals];
        const mergedBooks = [...new Set([...currentBooks, ...importedBooks])];
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(mergedData));
        localStorage.setItem(GOALS_KEY, JSON.stringify(mergedGoals));
        localStorage.setItem(BOOKS_KEY, JSON.stringify(mergedBooks));
      }
      
      // Signal to main page that data was imported
      sessionStorage.setItem('just_imported_data', 'true');
      
      await customAlert(`Data imported successfully!\n\n${importedData.length} entries imported.\n\nRedirecting to main page...`, 'Import Successful');
      
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 500);
    } catch (error) {
      console.error('Import error:', error);
      await customAlert('Error reading file: ' + error.message, 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = '';
});

document.getElementById('ttsuInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const ttsuData = JSON.parse(e.target.result);
      
      if (!Array.isArray(ttsuData)) {
        await customAlert('Invalid ttsu export format. Expected an array of reading sessions.', 'Invalid Format');
        return;
      }
      
      const transformedData = [];
      const currentData = getCurrentData();
      const currentBooks = getCurrentBooks();
      const bookTitles = new Set();
      
      ttsuData.forEach(session => {
        if (!session.dateKey || (session.charactersRead === 0 && session.readingTime === 0)) {
          return;
        }
        
        const date = session.dateKey;
        const minutes = Math.round(session.readingTime / 60);
        const characters = session.charactersRead || 0;
        
        if (minutes === 0 && characters === 0) return;
        
        const exists = currentData.some(entry => 
          entry.date === date && 
          entry.title === session.title &&
          Math.abs(entry.minutes - minutes) < 2 &&
          Math.abs(entry.characters - characters) < 100
        );
        
        if (!exists) {
          transformedData.push({
            date: date,
            minutes: minutes,
            characters: characters,
            title: session.title || 'Reading (from ttsu)'
          });
          bookTitles.add(session.title);
        }
      });
      
      if (transformedData.length === 0) {
        await customAlert('No new reading data found in ttsu export.\n\nAll sessions have either already been imported or contain no reading data.', 'No New Data');
        return;
      }
      
      const mergedData = [...currentData, ...transformedData];
      localStorage.setItem(STORAGE_KEY, JSON.stringify(mergedData));
      
      bookTitles.forEach(title => {
        if (title && !currentBooks.includes(title)) {
          currentBooks.unshift(title);
        }
      });
      const updatedBooks = currentBooks.slice(0, 10);
      localStorage.setItem(BOOKS_KEY, JSON.stringify(updatedBooks));
      
      // Signal import
      sessionStorage.setItem('just_imported_data', 'true');
      
      const bookList = Array.from(bookTitles).join(', ');
      await customAlert(
        `‚úÖ Successfully imported ${transformedData.length} reading session(s) from ttsu!\n\nBooks: ${bookList}\n\nRedirecting to main page...`,
        'Import Successful'
      );
      
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 500);
      
    } catch (error) {
      console.error('Import error:', error);
      await customAlert('Error importing ttsu data: ' + error.message + '\n\nPlease make sure you exported the correct JSON file from ttsu.', 'Import Error');
    }
  };
  
  reader.readAsText(file);
  event.target.value = '';
});

  async function wipeAllData() {
    const firstConfirm = await customConfirm(
      'Are you sure? This will permanently delete all reading data, goals, recent books, backups, and visibility preferences.\n\nThis action cannot be undone.',
      'Wipe All Data'
    );
    if (!firstConfirm) return;

    const secondConfirm = await customConfirm(
      'Really delete ALL data? Click OK to confirm.',
      'Final Confirmation'
    );
    if (!secondConfirm) return;

    try {
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(GOALS_KEY);
      localStorage.removeItem(BOOKS_KEY);
      localStorage.removeItem(BACKUPS_KEY);
      localStorage.removeItem(LAST_BACKUP_KEY);
      localStorage.removeItem(BACKUP_FREQUENCY_KEY);
      localStorage.removeItem(BACKUP_RETENTION_KEY);
      localStorage.removeItem('show_longestStreak');
      localStorage.removeItem('show_currentStreak');
      localStorage.removeItem('show_average');
      localStorage.removeItem('show_avgSpeed');
      localStorage.removeItem('show_total');
      localStorage.removeItem('selectedMetric');
      localStorage.removeItem(USER_KEY);
      
      sessionStorage.setItem('just_wiped_data', 'true');
      
      await customAlert('All data has been wiped. Redirecting to main page...', 'Data Wiped');
      
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 500);
    } catch (error) {
      await customAlert('Failed to wipe data: ' + error.message, 'Error');
    }
  }

  window.onload = function() {
  loadStatVisibility();
  loadBackupSettings();
  loadTtsuSyncStatus();
  
  // Check if auto-sync should start
  const enabled = localStorage.getItem('ttsu_sync_enabled') === 'true';
  if (enabled && window.startAutoSync) {
    window.startAutoSync();
  }
};

  // Custom themed confirm dialog
  function customConfirm(message, title = 'Confirm') {
    return new Promise((resolve) => {
      const modal = document.getElementById('confirmModal');
      const titleEl = document.getElementById('confirmTitle');
      const messageEl = document.getElementById('confirmMessage');
      const okBtn = document.getElementById('confirmOk');
      const cancelBtn = document.getElementById('confirmCancel');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      modal.style.display = 'flex';
      
      const handleOk = () => {
        cleanup();
        resolve(true);
      };
      
      const handleCancel = () => {
        cleanup();
        resolve(false);
      };
      
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          resolve(false);
        }
      };
      
      const cleanup = () => {
        modal.style.display = 'none';
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        document.removeEventListener('keydown', handleEscape);
      };
      
      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);
      document.addEventListener('keydown', handleEscape);
    });
  }

  // Custom themed alert dialog
  function customAlert(message, title = 'Notice') {
    return new Promise((resolve) => {
      const modal = document.getElementById('alertModal');
      const titleEl = document.getElementById('alertTitle');
      const messageEl = document.getElementById('alertMessage');
      const okBtn = document.getElementById('alertOk');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      modal.style.display = 'flex';
      
      const handleOk = () => {
        cleanup();
        resolve();
      };
      
      const handleEscape = (e) => {
        if (e.key === 'Escape' || e.key === 'Enter') {
          cleanup();
          resolve();
        }
      };
      
      const cleanup = () => {
        modal.style.display = 'none';
        okBtn.removeEventListener('click', handleOk);
        document.removeEventListener('keydown', handleEscape);
      };
      
      okBtn.addEventListener('click', handleOk);
      document.addEventListener('keydown', handleEscape);
      
      setTimeout(() => okBtn.focus(), 100);
    });
  }

  // ttsu sync functions placeholder (will load from external script if needed)
  window.setupTtsuSync = () => console.log('ttsu not loaded');
  window.manualSyncTtsu = () => console.log('ttsu not loaded');
  window.batchLoadAllTtsu = () => console.log('ttsu not loaded');
</script>

<!-- View Backups Modal -->
<div class="modal" id="viewBackupsModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 700px; max-width: 90vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Available Backups</h2>
    <div id="backupsList" style="margin-top: 16px;"></div>
    <button class="btn" onclick="closeViewBackupsModal()" style="width: 100%; margin-top: 16px;">Close</button>
  </div>
</div>

<!-- Custom Confirmation Modal -->
<div class="modal" id="confirmModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 460px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 id="confirmTitle" style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Confirm</h2>
    <p id="confirmMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0;"></p>
    <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
      <button class="btn" id="confirmCancel">Cancel</button>
      <button class="confirm-btn" id="confirmOk">OK</button>
    </div>
  </div>
</div>

<!-- Custom Alert Modal -->
<div class="modal" id="alertModal" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; align-items: center; justify-content: center;">
  <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 24px; width: 460px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);">
    <h2 id="alertTitle" style="margin-bottom: 16px; font-size: 18px; color: var(--text-primary);">Notice</h2>
    <p id="alertMessage" style="color: var(--text-secondary); font-size: 14px; line-height: 1.6; margin: 16px 0; white-space: pre-line;"></p>
    <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
      <button class="confirm-btn" id="alertOk" style="width: 100%;">OK</button>
    </div>
  </div>
</div>

</body>
</html>